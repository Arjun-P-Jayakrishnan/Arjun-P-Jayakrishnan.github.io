{"version":3,"sources":["../src/engine/managers/animation/GraphRuntime.ts"],"names":["AnimationGraph","nodes","n","fsm","params","node","weight"],"mappings":"AAuDO,IAAMA,CAAAA,CAAN,KAAsD,CAQ3D,WAAA,CAAYC,EAA6B,CANzC,IAAA,CAAQ,OAAoD,EAAC,CAO3D,KAAK,KAAA,CAAQ,IAAI,IAAIA,CAAAA,CAAM,GAAA,CAAKC,GAAM,CAACA,CAAAA,CAAE,IAAA,CAAMA,CAAC,CAAC,CAAC,EACpD,CAOA,IAAA,CAAKC,EAAiBC,CAAAA,CAA6B,CACjD,IAAMC,CAAAA,CAAO,IAAA,CAAK,MAAM,GAAA,CAAIF,CAAAA,CAAI,YAAY,CAAA,CAC5C,GAAI,CAACE,CAAAA,CAAM,CACT,KAAK,MAAA,CAAS,EAAC,CACf,MACF,CAIA,GAFA,KAAK,MAAA,CAAS,GAEVA,CAAAA,CAAK,IAAA,CAEP,KAAK,MAAA,CAAO,IAAA,CAAK,CAAE,IAAA,CAAMA,CAAAA,CAAK,KAAM,MAAA,CAAQ,CAAE,CAAC,CAAA,CAAA,KAAA,GACtCA,CAAAA,CAAK,MAAO,CAErB,IAAMC,CAAAA,CAASD,CAAAA,CAAK,KAAA,CAAMD,CAAM,EAE5BC,CAAAA,CAAK,IAAA,EACP,KAAK,MAAA,CAAO,IAAA,CAAK,CAAE,IAAA,CAAMA,CAAAA,CAAK,IAAA,CAAM,MAAA,CAAAC,CAAO,CAAC,EAEhD,CACF,CAMA,sBAAuB,CACrB,OAAO,CAAC,GAAG,IAAA,CAAK,MAAM,CACxB,CACF","file":"chunk-URDWKHZ5.js","sourcesContent":["import { FSMRuntime } from \"./FSM\";\nimport { AnimationParameters } from \"./Parameters\";\n\n/**\n * Represents a single animation clip.\n */\nexport interface AnimationClip {\n  /** Clip name */\n  name: string;\n\n  /** Duration of the clip in seconds */\n  duration: number;\n\n  /** Whether the clip should loop */\n  loop?: boolean;\n}\n\n/**\n * A node in the animation graph, corresponding to a FSM state or blend.\n */\nexport interface AnimationGraphNode {\n  /** Node name, usually matching FSM state */\n  name: string;\n\n  /** Animation clip for this node */\n  clip?: AnimationClip;\n\n  /**\n   * Optional blend function returning a weight (0..1)\n   * Can use animation parameters to compute weight dynamically\n   */\n  blend?: (params: AnimationParameters) => number;\n}\n\n/**\n * Interface for an animation graph runtime.\n */\nexport interface AnimationGraphRuntime {\n  /**\n   * Evaluate the graph for the current FSM state and parameters.\n   * @param fsm - The FSM runtime providing the current state\n   * @param params - The animation parameters used for blending\n   */\n  tick(fsm: FSMRuntime, params: AnimationParameters): void;\n\n  /**\n   * Get the currently active animation clips and their weights.\n   * @returns Array of active clips and weights\n   */\n  getCurrentAnimations(): { clip: AnimationClip; weight: number }[];\n}\n\n/**\n * Simple animation graph runtime that maps FSM states to animation clips.\n */\nexport class AnimationGraph implements AnimationGraphRuntime {\n  private nodes: Map<string, AnimationGraphNode>;\n  private active: { clip: AnimationClip; weight: number }[] = [];\n\n  /**\n   * Create a new AnimationGraph.\n   * @param nodes - Array of animation graph nodes\n   */\n  constructor(nodes: AnimationGraphNode[]) {\n    this.nodes = new Map(nodes.map((n) => [n.name, n]));\n  }\n\n  /**\n   * Tick the graph: update active animation based on FSM state and parameters.\n   * @param fsm - FSM runtime to read the current state\n   * @param params - Animation parameters for blending\n   */\n  tick(fsm: FSMRuntime, params: AnimationParameters) {\n    const node = this.nodes.get(fsm.currentState);\n    if (!node) {\n      this.active = [];\n      return;\n    }\n\n    this.active = [];\n\n    if (node.clip) {\n      // Single clip node\n      this.active.push({ clip: node.clip, weight: 1 });\n    } else if (node.blend) {\n      // Blend node\n      const weight = node.blend(params);\n      // For now, assume a single clip for blend\n      if (node.clip) {\n        this.active.push({ clip: node.clip, weight });\n      }\n    }\n  }\n\n  /**\n   * Get currently active animations with weights.\n   * @returns Array of { clip, weight } objects\n   */\n  getCurrentAnimations() {\n    return [...this.active];\n  }\n}\n"]}