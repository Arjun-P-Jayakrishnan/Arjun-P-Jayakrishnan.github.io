{"version":3,"sources":["../src/core/loader/loader.ts"],"names":["createLoader","context","scene","renderer","loaderEventBus","globalState","manager","LoadingManager","plugins","_configureLoadingManager","url","itemsLoaded","itemsTotal","_configurePlugins","modelDescriptors","environmentMap","glbDescriptors","fbxDescriptors","hdrDescriptors","model","createGLBLoader","createFBXLoader","createHDRLoader","assets","processPipelineDebugger","promises","plugin"],"mappings":"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","file":"chunk-PNS3BOIF.js","sourcesContent":["import { LoadingManager, Scene, WebGLRenderer } from \"three\";\nimport { createHDRLoader } from \"./plugins/hdr_loader\";\nimport { createGLBLoader } from \"./plugins/glb_loader\";\nimport { LoadingEvents } from \"@managers/events/eventType\";\nimport { createEventBus } from \"@managers/events/eventBus\";\nimport { GlobalState } from \"@managers/state/globalState\";\nimport { LoadingContext } from \"@managers/state/globalStateData\";\nimport { processPipelineDebugger } from \"debug/debugger\";\nimport { createFBXLoader } from \"./plugins/fbx_loader\";\nimport {\n  LoaderPlugin,\n  ModelAssetDescriptor,\n  ModelAssetRegistry,\n} from \"@utils/types/loading\";\nimport { Nullable } from \"@utils/types/lifecycle\";\n\nexport interface LoadOptions {\n  source: ModelAssetRegistry;\n}\n\nexport interface LoaderContext {\n  scene: Scene;\n  renderer: WebGLRenderer;\n  loaderEventBus: ReturnType<typeof createEventBus<LoadingEvents>>;\n  globalState: GlobalState;\n}\n\nexport interface Loader {\n  configure: () => void;\n  load: (assets: LoadOptions) => Promise<{\n    success: string[];\n    error: string[];\n  }>;\n  dispose: () => void;\n}\n/**\n * @description creates a loader with the given settings\n * @param options options to change loader settings\n * @param context global context with references\n * @returns Loader\n */\nexport const createLoader = (context: LoaderContext): Loader => {\n  const { scene, renderer, loaderEventBus, globalState } = context;\n\n  const manager: LoadingManager = new LoadingManager();\n  let plugins: LoaderPlugin[] = [];\n\n  /**\n   * @description attaches the event bus for listening to loading changes\n   */\n  const _configureLoadingManager = () => {\n    manager.onStart = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:start\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      globalState.setState({\n        loading: { active: true, progress: 0 } as LoadingContext,\n      });\n    };\n\n    manager.onProgress = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:progress\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      globalState.setState({\n        loading: {\n          active: true,\n          progress: itemsLoaded / itemsTotal,\n        } as LoadingContext,\n      });\n    };\n\n    manager.onLoad = () => {\n      loaderEventBus.emit({\n        type: \"load:complete\",\n      });\n    };\n\n    manager.onError = (url) => {\n      loaderEventBus.emit({\n        type: \"load:error\",\n        url: url,\n      });\n    };\n  };\n\n  /**\n   * @description create necessary loaders\n   */\n  const _configurePlugins = ({\n    modelDescriptors,\n    environmentMap,\n  }: ModelAssetRegistry) => {\n    const glbDescriptors: ModelAssetDescriptor[] = [];\n    const fbxDescriptors: ModelAssetDescriptor[] = [];\n    const hdrDescriptors: Nullable<ModelAssetDescriptor> =\n      environmentMap ?? null;\n\n    modelDescriptors.forEach((model) => {\n      switch (model.loaderType) {\n        case \"glb\":\n          glbDescriptors.push(model);\n          break;\n        case \"fbx\":\n          fbxDescriptors.push(model);\n          break;\n        default:\n          break;\n      }\n    });\n\n    plugins.push(\n      createGLBLoader({\n        assets: glbDescriptors,\n        scene: scene,\n        loadingManager: manager,\n        loadingEventBus: loaderEventBus,\n      })\n    );\n    plugins.push(\n      createFBXLoader({\n        assets: fbxDescriptors,\n        scene: scene,\n        loadingManager: manager,\n        loadingEventBus: loaderEventBus,\n      })\n    );\n\n    if (hdrDescriptors !== null) {\n      plugins.push(\n        createHDRLoader({\n          asset: hdrDescriptors,\n          scene: scene,\n          renderer: renderer,\n          loadingManager: manager,\n          loadingEventBus: loaderEventBus,\n        })\n      );\n    }\n  };\n\n  /**\n   * @description configuration\n   */\n  const _configure = () => {\n    _configureLoadingManager();\n  };\n\n  /**\n   * @description load all types of assets\n   */\n  const load = async (\n    assets: LoadOptions\n  ): Promise<{ success: []; error: [] }> => {\n    processPipelineDebugger.onInit(\n      `loading the models ${JSON.stringify(assets)}`\n    );\n\n    const promises: Promise<void>[] = [];\n    _configurePlugins(assets.source);\n\n    plugins.forEach((plugin) => {\n      promises.push(plugin.load());\n    });\n\n    await Promise.allSettled(promises);\n\n    plugins = [];\n\n    processPipelineDebugger.onInit(`loaded models i guess`);\n\n    return {\n      success: [],\n      error: [],\n    };\n  };\n\n  const dispose = () => {\n    plugins.forEach((plugin) => {\n      plugin.dispose?.();\n    });\n  };\n\n  return {\n    configure: _configure,\n    load: load,\n    dispose: dispose,\n  };\n};\n"]}