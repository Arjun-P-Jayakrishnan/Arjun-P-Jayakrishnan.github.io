{"version":3,"sources":["../src/utils/state/observable.ts"],"names":["createObservable","props","value","listeners","_value","fn"],"mappings":"AAuCO,IAAMA,CACXC,CAAAA,CAAAA,EACkB,CAClB,IAAIC,CAAQD,CAAAA,CAAAA,CAAM,OACZE,CAAAA,CAAAA,CAAmC,IAAI,GAAA,CA8C7C,OAAO,MAAA,CAAO,MAAO,CAAA,CACnB,QAxBgB,CAAA,IACTD,CAwBP,CAAA,QAAA,CAzCgBE,CAAc,EAAA,CAC1BF,CAAUE,GAAAA,CAAAA,GAGdF,CAAQE,CAAAA,CAAAA,CAEN,UAAA,CAAW,IAAM,CACfD,CAAAA,CAAU,OAASE,CAAAA,CAAAA,EAAOA,CAAGD,CAAAA,CAAM,CAAC,EACtC,CAAG,CAAA,CAAC,CAER,EAAA,CAAA,CAgCE,kBAjB0BC,CAAAA,CAAAA,GAC1BF,CAAU,CAAA,GAAA,CAAIE,CAAE,CAAA,CACT,IAAM,CACXF,CAAU,CAAA,MAAA,CAAOE,CAAE,EACrB,CAcA,CAAA,CAAA,OAAA,CARc,IAAM,CACpBF,CAAU,CAAA,KAAA,GACZ,CAOA,CAAC,CACH","file":"chunk-XVCKZLMV.js","sourcesContent":["/**\n * Properties of observable\n */\nexport interface ObservableProps<T> {\n  initial: T;\n}\n\n/**\n * Observable methods\n */\nexport interface Observable<T> {\n  /**\n   *\n   * @description gets current state\n   * @returns currents state\n   */\n  getValue: () => T;\n  /**\n   * @description changes the current state to new state and notifies all listeners\n   * @param value the new state\n   */\n  setValue: (value: T) => void;\n  /**\n   * @description allows to look for changes\n   * @param fn callback function to be run when state changes\n   * @returns un subscribe function reference to unsubscribe when no longer needed\n   */\n  subscribeToChanges: (fn: (val: T) => void) => () => void;\n  /**\n   * @description allows clean up of unsubscribed functions\n   */\n  dispose: () => void;\n}\n\n/**\n * @description creates an observable for the given type with a initial state\n * @param props initial state of observable\n * @returns observable\n */\nexport const createObservable = <T>(\n  props: ObservableProps<T>\n): Observable<T> => {\n  let value = props.initial;\n  const listeners: Set<(val: T) => void> = new Set();\n  let scheduled: boolean = false;\n\n  /**\n   * @description changes the state to new state and notifies all listeners\n   * @param _value the new state\n   */\n  const setValue = (_value: T) => {\n    if (value === _value) {\n      return;\n    }\n    value = _value;\n    if (!scheduled) {\n      setTimeout(() => {\n        listeners.forEach((fn) => fn(_value));\n      }, 0);\n    }\n  };\n\n  /**\n   * @description gets the data of current state\n   * @returns the current state\n   */\n  const _getValue = () => {\n    return value;\n  };\n\n  /**\n   * @description subscribe to state changes\n   * @param fn the callback function when the state changes\n   * @returns un subscribe function to clean up\n   */\n  const subscribeToChanges = (fn: (val: T) => void) => {\n    listeners.add(fn);\n    return () => {\n      listeners.delete(fn);\n    };\n  };\n\n  /**\n   * @description clears the set so that there are no memory leaks\n   */\n  const dispose = () => {\n    listeners.clear();\n  };\n\n  return Object.freeze({\n    getValue: _getValue,\n    setValue: setValue,\n    subscribeToChanges: subscribeToChanges,\n    dispose: dispose,\n  });\n};\n"]}