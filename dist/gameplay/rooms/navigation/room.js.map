{"version":3,"sources":["../../../../src/engine/core/ServiceRegistry.ts","../../../../src/gameplay/rooms/navigation/room.ts","../../../../src/gameplay/rooms/navigation/camera.ts","../../../../src/materials/grid/grid-fragment.ts","../../../../src/materials/grid/grid-vertex.ts","../../../../src/materials/grid/grid-material.ts","../../../../src/gameplay/rooms/navigation/ground.ts","../../../../src/gameplay/modules/animation.ts","../../../../src/gameplay/modules/fsm/player.ts","../../../../src/gameplay/rooms/navigation/player.ts"],"names":["createServiceRegistry","services","name","service","serviceRegistry","getServiceRegistry","TPV_CONFIG","tempPosition","Vector3","tempOffset","tempLookTarget","clampRotation","yaw","pitch","MathUtils","computeThirdPersonOffset","spherical","lerpVector","from","to","alpha","createCameraManager","camera","isThirdPerson","state","Spherical","setCamera","mode","mount","activate","updateRotation","delta","clamped","updateThirdPerson","info","updateFirstPerson","playerPos","GridFragment","GridVertex","createGridMaterial","props","mat","ShaderMaterial","cameraPos","createGround","logger","references","storage","ground","gridMat","createAnimationController","mixer","actions","crossFadeDuration","currentAnimation","currentAction","animationName","blendDuration","nextAction","deltaTime","Idle","player","Walk","Run","createFSMController","inputs","animationController","keyboard","shiftPressed","idle","walk","run","currentState","update","playerFSM","isMoving","isShiftPressed","_getState","newState","changeState","PLAYER_CONSTANTS","createPlayer","reference","InputManager","controllers","tempData","objects","playerRoot","animations","AnimationMixer","fsmController","err","updateMouse","mouse","updateKeyboard","VELOCITY_DEADZONE","inputDirection","decay","updateControllers","Euler","createNavigationRoom","eventBusManager","contextManager","components","room","isMounted"],"mappings":"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","file":"room.js","sourcesContent":["import {\n  ServiceKey,\n  ServiceMap,\n  ServiceRegistry,\n  ServiceType,\n} from \"types/service.types\";\n\nconst createServiceRegistry = (): ServiceRegistry => {\n  const services: Map<ServiceKey, ServiceType> = new Map<\n    ServiceKey,\n    ServiceType\n  >();\n\n  const register = <K extends ServiceKey>(\n    name: K,\n    service: ServiceMap[K]\n  ): void => {\n    if (services.has(name)) {\n      throw new Error(`Error : Redefining the service [${name}]`);\n    }\n    services.set(name, service);\n  };\n\n  const get = <K extends ServiceKey>(name: K): ServiceMap[K] => {\n    const service = services.get(name);\n    if (!service) {\n      throw new Error(\n        `Error : Trying to obtain value of an unregistered service ${name}`\n      );\n    }\n    return service as ServiceMap[K];\n  };\n\n  const has = (name: ServiceKey): boolean => {\n    return services.has(name);\n  };\n\n  return {\n    register: register,\n    get: get,\n    has: has,\n  };\n};\n\nlet serviceRegistry: ServiceRegistry | undefined = undefined;\n\nconst getServiceRegistry = () => {\n  if (!serviceRegistry) {\n    serviceRegistry = createServiceRegistry();\n  }\n\n  return serviceRegistry;\n};\n\nexport { getServiceRegistry };\n","import { getServiceRegistry } from \"engine/core/ServiceRegistry\";\nimport { InputManager } from \"engine/managers/InputManager\";\nimport { Euler, Vector3 } from \"three\";\nimport { ObjectStorageUnit } from \"types/managers.types\";\nimport { ModelIdentifier, Room } from \"types/rooms.types\";\nimport { CameraManager, createCameraManager } from \"./camera\";\nimport { createGround, Ground } from \"./ground\";\nimport { createPlayer, Player } from \"./player\";\n\nexport interface NavigationRoomProps {\n  player: ModelIdentifier;\n  ground: ModelIdentifier;\n}\n\ninterface Entities {\n  player: Player;\n  ground: Ground;\n  camera: CameraManager;\n  inputs: InputManager;\n}\n\ninterface InternalState {\n  player: {\n    position: Vector3;\n    rotation: Euler;\n    rotationDelta: { yaw: number; pitch: number };\n  };\n}\n\ninterface TempData {}\n\nexport const createNavigationRoom = ({\n  player,\n  ground,\n}: NavigationRoomProps): Room => {\n  //External dependencies\n  const serviceRegistry = getServiceRegistry();\n\n  const [logger, storage, eventBusManager, InputManager, contextManager] = [\n    serviceRegistry.get(\"Logger\"),\n    serviceRegistry.get(\"GlobalStorageManager\"),\n    serviceRegistry.get(\"EventBusManager\"),\n    serviceRegistry.get(\"InputManager\"),\n    serviceRegistry.get(\"ThreeJSContextManager\"),\n  ];\n\n  //Internal\n  let components: Nullable<Entities> = {\n    camera: createCameraManager({ camera: contextManager.get(\"camera\")! }),\n    player: createPlayer({\n      reference: player,\n      InputManager: InputManager,\n      storage: storage,\n    }),\n    ground: createGround({\n      camera: contextManager.get(\"camera\")!,\n      logger: logger,\n      references: ground,\n      storage: storage,\n    }),\n    inputs: InputManager,\n  };\n\n  //TODO:no idea on what to add yet\n  let state: Nullable<InternalState> = null;\n  //TODO: no idea what temporary data to add yet\n  let tempData: Nullable<TempData> = null;\n\n  let room: Nullable<ObjectStorageUnit> = null;\n  let isMounted: boolean = false;\n\n  const activate = () => {\n    if (!room || !components) return;\n    room.groups.visible = true;\n    contextManager.get(\"orbit\")!.enabled = false;\n\n    components.camera.activate();\n    components.ground.activate();\n    components.player.activate();\n  };\n\n  const deactivate = () => {\n    if (!room || !components) return;\n    room.groups.visible = false;\n\n    components.camera.deactivate();\n    components.ground.deactivate();\n    components.player.deactivate();\n  };\n\n  const mount = () => {\n    if (isMounted || !components) return;\n\n    logger.onMount({ origin: \"Navigation Room\" });\n    state = {\n      player: {\n        position: new Vector3(0, 0, 0),\n        rotation: new Euler(0, 0, 0),\n        rotationDelta: { yaw: 0, pitch: 0 },\n      },\n    };\n\n    //get base root i.e group so that it can be used to toggle visibility\n    room = storage.getStorage(\"model\").retrieve(ground.storageId) ?? null;\n\n    components.player.mount();\n    components.ground.mount();\n    components.camera.mount();\n\n    isMounted = true;\n  };\n\n  const update = (deltaTime: number) => {\n    if (!isMounted || !components || !state) return;\n    contextManager.get(\"orbit\")!.update();\n    state.player = components.player.update(deltaTime);\n    components.camera.update({\n      playerPosition: state.player.position,\n      rotationDelta: state.player.rotationDelta,\n    });\n\n    //entities.ground.update();\n  };\n\n  const unmount = () => {\n    if (!isMounted || !components) return;\n\n    logger.onUnmount({ origin: \"Navigation Room\" });\n\n    components.player.unmount();\n    components.ground.unmount();\n\n    components = null;\n    room = null;\n  };\n\n  return {\n    mount: mount,\n    update: update,\n    unmount: unmount,\n    setActive: activate,\n    setDeactive: deactivate,\n    isLoaded: false,\n  };\n};\n","import { Euler, MathUtils, PerspectiveCamera, Spherical, Vector3 } from \"three\";\nimport { GenericLifeCycle } from \"types/rooms.types\";\n\nexport type CameraMode = \"firstPerson\" | \"thirdPerson\";\n\nexport interface CameraProps {\n  /**Main Camera */\n  camera: PerspectiveCamera;\n}\n\n/** Contains the Updated info about player */\nexport type UpdatedInfo = {\n  playerPosition: Vector3;\n  rotationDelta: { yaw: number; pitch: number };\n};\n\n/** Controls to manage camera */\nexport interface CameraManager extends GenericLifeCycle {\n  /** Updates the camera to look the player */\n  update: (info: UpdatedInfo) => { rotation: Euler };\n\n  /**sets the mode of camera */\n  setMode: (mode: CameraMode) => void;\n}\n\n//Third Person Config\nconst TPV_CONFIG = {\n  DISTANCE: 3,\n  HEIGHT_OFFSET: 2,\n  PITCH_MIN: 0,\n  PITH_MAX: Math.PI / 2,\n  SMOOTHING: 0.1,\n} as const;\n\n//Temporary Variables\n\nlet tempPosition = new Vector3(0, 0, 0);\nlet tempOffset = new Vector3(0, 0, 0);\nlet tempLookTarget = new Vector3(0, 0, 0);\n\n/**\n *\n * @param yaw the yaw angle\n * @param pitch the pitch angle\n * @returns restricted angles\n */\nfunction clampRotation(\n  yaw: number,\n  pitch: number\n): { yaw: number; pitch: number } {\n  return {\n    yaw: MathUtils.euclideanModulo(yaw, Math.PI * 2),\n    pitch: MathUtils.clamp(pitch, TPV_CONFIG.PITCH_MIN, TPV_CONFIG.PITH_MAX),\n  };\n}\n\n/**\n *\n * @param spherical the spherical coordinates\n * @returns the Vector based on spherical coordinates\n */\nfunction computeThirdPersonOffset(spherical: Spherical): Vector3 {\n  tempOffset.set(0, 0, 0);\n  tempOffset.setFromSpherical(spherical);\n  tempOffset.y += TPV_CONFIG.HEIGHT_OFFSET;\n\n  return tempOffset;\n}\n\n/**\n * Smoothly interpolate value between from and to vectors based on alpha\n */\nfunction lerpVector(from: Vector3, to: Vector3, alpha: number) {\n  return from.lerp(to, alpha);\n}\n\ninterface InternalState {\n  mode: CameraMode;\n  rotation: { yaw: number; pitch: number };\n  spherical: Spherical;\n}\n\nexport const createCameraManager = ({ camera }: CameraProps): CameraManager => {\n  let isThirdPerson: boolean = true;\n  let state: InternalState = {\n    mode: \"thirdPerson\",\n    rotation: { pitch: Math.PI / 2, yaw: 0 },\n    spherical: new Spherical(TPV_CONFIG.DISTANCE, Math.PI / 2, 0),\n  };\n\n  const setCamera = (mode: CameraMode) => {\n    state.mode = mode;\n  };\n\n  const mount = () => {};\n\n  const activate = () => {\n    camera.position.set(1, 2, 3);\n  };\n\n  /**\n   *\n   * @param yaw\n   * @param pitch\n   */\n  const updateRotation = (delta: { yaw: number; pitch: number }) => {\n    state.rotation.yaw += delta.yaw;\n    state.rotation.pitch += delta.pitch;\n\n    const clamped = clampRotation(state.rotation.yaw, state.rotation.pitch);\n    state.rotation.yaw = clamped.yaw;\n    state.rotation.pitch = clamped.pitch;\n  };\n\n  const updateThirdPerson = (info: UpdatedInfo) => {\n    state.spherical.theta = state.rotation.yaw;\n    state.spherical.phi = state.rotation.pitch;\n\n    //Calculate offset\n    tempOffset.copy(computeThirdPersonOffset(state.spherical));\n\n    //Calculate target position and camera lerp smoothly\n    tempPosition.copy(info.playerPosition).add(tempOffset);\n    camera.position.copy(\n      lerpVector(camera.position, tempPosition, TPV_CONFIG.SMOOTHING)\n    );\n\n    tempLookTarget.copy(info.playerPosition);\n    tempLookTarget.y += TPV_CONFIG.HEIGHT_OFFSET;\n    camera.lookAt(tempLookTarget);\n  };\n\n  const updateFirstPerson = (playerPos: Vector3) => {\n    camera.position.copy(playerPos);\n    camera.rotation.set(state.rotation.pitch, state.rotation.yaw, 0);\n  };\n\n  const update = (info: UpdatedInfo): { rotation: Euler } => {\n    updateRotation(info.rotationDelta);\n\n    if (state.mode === \"thirdPerson\") {\n      updateThirdPerson(info);\n    } else {\n      updateFirstPerson(info.playerPosition);\n    }\n\n    return {\n      rotation: camera.rotation,\n    };\n  };\n\n  const deactivate = () => {};\n\n  const unmount = () => {};\n\n  return {\n    setMode: setCamera,\n    update: update,\n    mount: mount,\n    activate: activate,\n    deactivate: deactivate,\n    unmount: unmount,\n  };\n};\n","export const GridFragment = `\n    precision highp float;\n\n    varying vec2 vUV;\n\n    float line(vec2 uv,float lineWidth){\n\n       \n        float lineAA=fwidth(uv.x);\n \n        float lineUV=1.0-abs(fract(uv.x)*2.0-1.0);\n\n        return smoothstep(lineWidth+lineAA,lineWidth-lineAA,lineUV);\n    }  \n\n    float grid(vec2 uv,float lineWidth){\n\n        vec2 uvDeriv=fwidth(uv);\n        vec2 drawWidth=max(vec2(lineWidth),uvDeriv);\n        vec2 lineAA=uvDeriv*1.5;\n \n        vec2 gridUV=1.0-abs(fract(uv)*2.0-1.0);\n\n        vec2 gridLines=smoothstep(drawWidth+lineAA,drawWidth-lineAA,gridUV);\n        gridLines*=clamp(lineWidth/drawWidth,0.0,1.0);\n\n        return mix(gridLines.x,1.0,gridLines.y);\n    } \n\n    void main(){\n        vec2 st=vUV*1500.0;\n       \n        gl_FragColor = vec4(vec3(grid(st,0.01)),1.0);\n    }\n\n`;\n","export const GridVertex = `\n    precision highp float;\n\n    \n\n    varying vec2 vUV;\n    varying vec4 vWorldPos; \n\n    void main(){\n        vUV=uv;\n        vWorldPos=modelViewMatrix*vec4(position,1.0);\n\n        gl_Position = projectionMatrix*modelViewMatrix*vec4(position,1.0);\n    }\n\n`;\n","import { PerspectiveCamera, ShaderMaterial, Vector3 } from \"three\";\nimport { GridFragment } from \"./grid-fragment\";\nimport { GridVertex } from \"./grid-vertex\";\n\nexport interface GridMaterialProps {\n  camera: PerspectiveCamera;\n  fadeNear: number;\n  fadeFar: number;\n}\n\nexport interface GridMaterial {\n  mat: ShaderMaterial;\n  update: (cameraPos: Vector3) => void;\n}\n\nexport const createGridMaterial = (props: GridMaterialProps) => {\n  const mat: ShaderMaterial = new ShaderMaterial({\n    uniforms: {\n      time: { value: 1 },\n      cameraPos: { value: props.camera.position },\n      fadeNear: { value: props.fadeNear },\n      fadeFar: { value: props.fadeFar },\n    },\n    vertexShader: GridVertex,\n    fragmentShader: GridFragment,\n  });\n\n  const update = (cameraPos: Vector3) => {\n    mat.uniforms.cameraPos.value = cameraPos;\n  };\n\n  return {\n    mat: mat,\n    update: update,\n  };\n};\n","import { Logger } from \"@utils/Logger\";\nimport { GlobalStorageManager } from \"engine/managers/storage/storageTypes\";\nimport { createGridMaterial, GridMaterial } from \"materials/grid/grid-material\";\nimport { Mesh, PerspectiveCamera } from \"three\";\nimport { ModelIdentifier } from \"types/rooms.types\";\n\nexport interface GroundProps {\n  references: ModelIdentifier;\n  storage: GlobalStorageManager;\n  logger: Logger;\n  camera: PerspectiveCamera;\n}\n\nexport interface Ground {\n  mount: () => void;\n  update: () => void;\n  activate: () => void;\n  deactivate: () => void;\n  unmount: () => void;\n}\n\nexport const createGround = ({\n  logger,\n  references,\n  storage,\n  camera,\n}: GroundProps): Ground => {\n  let ground: Nullable<Mesh> = null;\n  let gridMat: Nullable<GridMaterial> = null;\n\n  const mount = () => {\n    ground =\n      (storage\n        .getStorage(\"model\")\n        .retrieve(references.storageId)\n        ?.groups.getObjectByName(references.id) as Mesh) ?? null;\n\n    if (!ground) {\n      console.error(\n        `Cant get ground mesh from the id : ${references.id} ${references.storageId}`\n      );\n      return;\n    }\n\n    gridMat = createGridMaterial({\n      camera: camera,\n      fadeNear: 0.1,\n      fadeFar: 1,\n    });\n\n    ground.material = gridMat.mat;\n    logger.onMount({ origin: \"Navigation-Ground\" });\n  };\n\n  const update = () => {\n    gridMat?.update(camera.position);\n  };\n\n  const activate = () => {};\n  const deactivate = () => {};\n\n  const unmount = () => {};\n\n  return {\n    mount: mount,\n    update: update,\n    activate: activate,\n    deactivate: deactivate,\n    unmount: unmount,\n  };\n};\n","import { AnimationAction, AnimationMixer } from \"three\";\n\nexport interface AnimationControllerProps {\n  mixer: AnimationMixer;\n  actions: Record<string, AnimationAction>;\n  crossFadeDuration: 0.3;\n}\n\nexport interface AnimationController {\n  play: (animationName: string, blendDuration?: number) => void;\n  stop: () => void;\n  getCurrentAnimation: () => string | null;\n  update: (deltaTime: number) => void;\n}\n\nexport const createAnimationController = ({\n  mixer,\n  actions,\n  crossFadeDuration = 0.3,\n}: AnimationControllerProps): AnimationController => {\n  let currentAnimation: Nullable<string> = null;\n  let blendTime: number = 0;\n  let currentAction: Nullable<AnimationAction> = null;\n\n  const play = (animationName: string, blendDuration = 0) => {\n    if (currentAnimation === animationName) return;\n\n    const nextAction = actions[animationName];\n    if (!nextAction) return;\n    nextAction.reset();\n    nextAction.play();\n\n    if (currentAction != null) {\n      (currentAction as AnimationAction).crossFadeTo(\n        nextAction,\n        crossFadeDuration,\n        false\n      );\n    }\n\n    currentAction = nextAction;\n    currentAnimation = animationName;\n  };\n\n  const stop = () => {};\n\n  const getCurrentAnimation = () => {\n    return currentAnimation;\n  };\n\n  const update = (deltaTime: number) => {\n    if (deltaTime !== undefined) mixer.update(deltaTime);\n  };\n\n  return {\n    play: play,\n    getCurrentAnimation: getCurrentAnimation,\n    stop: stop,\n    update: update,\n  };\n};\n","import { InputManager } from \"engine/managers/InputManager\";\nimport { AnimationController } from \"../animation\";\n\ntype States = \"Idle\" | \"Walk\" | \"Run\";\n\ninterface PlayerFSM {\n  changeState: (state: States) => void;\n  isMoving: () => boolean;\n  isShiftPressed: () => boolean;\n}\n\ninterface StateProps {\n  animationId: string;\n  animationController: AnimationController;\n}\n\ninterface State {\n  enter: (player: PlayerFSM) => void;\n  execute: (player: PlayerFSM) => void;\n  exit: (player: PlayerFSM) => void;\n}\n\nconst Idle = (props: StateProps): State => {\n  const enter = (player: PlayerFSM) => {\n    console.log(\"enter idle\");\n    props.animationController.play(props.animationId);\n  };\n\n  const execute = (player: PlayerFSM) => {\n    if (player.isMoving()) {\n      if (player.isShiftPressed()) {\n        player.changeState(\"Run\");\n      } else {\n        player.changeState(\"Walk\");\n      }\n    }\n  };\n\n  const exit = (player: PlayerFSM) => {\n    console.log(\"exit idle\");\n  };\n\n  return {\n    enter: enter,\n    execute: execute,\n    exit: exit,\n  };\n};\n\nconst Walk = (props: StateProps): State => {\n  const enter = (player: PlayerFSM) => {\n    console.log(\"enter walk\");\n    props.animationController.play(props.animationId);\n  };\n\n  const execute = (player: PlayerFSM) => {\n    if (!player.isMoving()) {\n      player.changeState(\"Idle\");\n    } else if (player.isShiftPressed()) {\n      player.changeState(\"Run\");\n    }\n  };\n\n  const exit = (player: PlayerFSM) => {\n    console.log(\"exit walk\");\n  };\n\n  return {\n    enter: enter,\n    execute: execute,\n    exit: exit,\n  };\n};\n\nconst Run = (props: StateProps): State => {\n  const enter = (player: PlayerFSM) => {\n    console.log(\"enter run\");\n    props.animationController.play(props.animationId);\n  };\n\n  const execute = (player: PlayerFSM) => {\n    if (!player.isMoving()) {\n      player.changeState(\"Idle\");\n    } else if (!player.isShiftPressed()) {\n      player.changeState(\"Walk\");\n    }\n  };\n\n  const exit = (player: PlayerFSM) => {\n    console.log(\"exit run\");\n  };\n\n  return {\n    enter: enter,\n    execute: execute,\n    exit: exit,\n  };\n};\n\nexport interface FSMOptions {\n  inputs: InputManager;\n  animationController: AnimationController;\n}\n\nexport interface FSMController {\n  mount: () => void;\n  update: (deltaTime: number) => void;\n  unmount: () => void;\n}\n\nexport const createFSMController = ({\n  inputs,\n  animationController,\n}: FSMOptions): FSMController => {\n  const { mouse, keyboard } = {\n    mouse: inputs.getController(\"mouse\"),\n    keyboard: inputs.getController(\"keyboard\"),\n  };\n\n  let shiftPressed: boolean;\n  const { idle, walk, run } = {\n    idle: Idle({\n      animationController: animationController,\n      animationId: \"Idle\",\n    }),\n    walk: Walk({\n      animationController: animationController,\n      animationId: \"Walk\",\n    }),\n    run: Run({\n      animationController: animationController,\n      animationId: \"Run\",\n    }),\n  };\n  let state: State = idle;\n  let currentState: States = \"Idle\";\n\n  const update = (deltaTime: number) => {\n    state.execute(playerFSM);\n    animationController.update(deltaTime);\n  };\n\n  const isMoving = () => {\n    if (\n      keyboard?.isKeyPressed(\"w\") ||\n      keyboard?.isKeyPressed(\"a\") ||\n      keyboard?.isKeyPressed(\"s\") ||\n      keyboard?.isKeyPressed(\"d\")\n    ) {\n      return true;\n    }\n\n    return false;\n  };\n\n  const isShiftPressed = () => {\n    return keyboard?.isKeyPressed(\"shift\") ?? false;\n  };\n\n  const _getState = (newState: States) => {\n    switch (newState) {\n      case \"Idle\":\n        return idle;\n      case \"Walk\":\n        return walk;\n      case \"Run\":\n        return run;\n      default:\n        return idle;\n    }\n  };\n\n  const changeState = (newState: States) => {\n    if (currentState !== newState) {\n      currentState = newState;\n      state.exit(playerFSM);\n      state = _getState(newState);\n      state.enter(playerFSM);\n    }\n  };\n\n  const mount = () => {\n    state.enter(playerFSM);\n  };\n\n  const playerFSM: PlayerFSM = {\n    changeState: changeState,\n    isMoving: isMoving,\n    isShiftPressed: isShiftPressed,\n  };\n\n  const unmount = () => {};\n\n  return {\n    mount: mount,\n    update: update,\n    unmount: unmount,\n  };\n};\n","import { InputManager } from \"engine/managers/InputManager\";\nimport { GlobalStorageManager } from \"engine/managers/storage/storageTypes\";\nimport {\n  AnimationController,\n  createAnimationController,\n} from \"gameplay/modules/animation\";\nimport {\n  createFSMController,\n  FSMController,\n} from \"gameplay/modules/fsm/player\";\nimport { KeyboardInput } from \"plugins/input/keyboard\";\nimport { MouseInput } from \"plugins/input/mouse\";\nimport { AnimationMixer, Euler, Object3D, Vector3 } from \"three\";\nimport { GenericLifeCycle, ModelIdentifier } from \"types/rooms.types\";\n\nexport interface PlayerProps {\n  reference: ModelIdentifier;\n  storage: GlobalStorageManager;\n  InputManager: InputManager;\n}\n\nexport interface Player extends GenericLifeCycle {\n  /** Update based on controller input */\n  update: (deltaTime: number) => {\n    position: Vector3;\n    rotation: Euler;\n    rotationDelta: { yaw: number; pitch: number };\n  };\n}\n\ninterface PlayerState {\n  direction: Vector3;\n  velocity: Vector3;\n  rotationApplied: {\n    yaw: number;\n    pitch: number;\n  };\n}\n\ninterface Controllers {\n  input: {\n    mouse: Nullable<MouseInput>;\n    keyboard: Nullable<KeyboardInput>;\n  };\n  animation: AnimationController;\n  fsm: FSMController;\n}\n\ninterface ObjectReferences {\n  player: Nullable<Object3D>;\n}\n\nconst PLAYER_CONSTANTS = {\n  MOVEMENT_ACCELERATION: 0.05,\n  MAX_VELOCITY: 0.05,\n};\n\ninterface TempData {\n  inputDirection: Vector3;\n}\n\nexport const createPlayer = ({\n  reference,\n  storage,\n  InputManager,\n}: PlayerProps): Player => {\n  let controllers: Controllers;\n\n  let state: PlayerState = {\n    direction: new Vector3(0, 0, -1),\n    velocity: new Vector3(0, 0, 0),\n    rotationApplied: {\n      pitch: 0,\n      yaw: 0,\n    },\n  };\n  let tempData: TempData = {\n    inputDirection: new Vector3(0, 0, 0),\n  };\n\n  let objects: ObjectReferences = { player: null };\n\n  const mount = () => {\n    try {\n      const playerRoot = storage\n        .getStorage(\"model\")\n        .retrieve(reference.storageId);\n\n      if (!playerRoot) {\n        throw new Error(\n          `player doesn't exist for the id ${reference.storageId}`\n        );\n      }\n      const player = playerRoot?.groups;\n      const animations = playerRoot?.animations;\n\n      /**Animation */\n      const mixer = new AnimationMixer(player);\n      const animationController = createAnimationController({\n        mixer: mixer,\n        actions: {\n          Idle: mixer.clipAction(animations[0]),\n          Walk: mixer.clipAction(animations[3]),\n          Run: mixer.clipAction(animations[1]),\n        },\n        crossFadeDuration: 0.3,\n      });\n\n      const fsmController = createFSMController({\n        animationController: animationController,\n        inputs: InputManager,\n      });\n      fsmController.mount();\n\n      objects = {\n        player: player,\n      };\n\n      controllers = {\n        input: {\n          mouse: InputManager.getController(\"mouse\"),\n          keyboard: InputManager.getController(\"keyboard\"),\n        },\n        animation: animationController,\n        fsm: fsmController,\n      };\n    } catch (err) {\n      console.error(`Player mesh cant be obtained :${err}`);\n    }\n  };\n\n  const updateMouse = (mouse: Nullable<MouseInput>) => {\n    if (!mouse || !objects.player!) return;\n\n    state.rotationApplied = mouse.getRotation();\n    objects.player.rotation.y += state.rotationApplied.yaw;\n  };\n\n  const updateKeyboard = (\n    keyboard: Nullable<KeyboardInput>,\n    deltaTime: number\n  ) => {\n    if (!keyboard || !objects.player) return;\n    const FRICTION = 5.0;\n    const VELOCITY_DEADZONE = 0.001;\n\n    const { inputDirection } = tempData;\n    inputDirection.set(0, 0, 0);\n\n    if (keyboard.isKeyPressed(\"w\")) inputDirection.z -= 1;\n    if (keyboard.isKeyPressed(\"s\")) inputDirection.z += 1;\n    if (keyboard.isKeyPressed(\"a\")) inputDirection.x -= 1;\n    if (keyboard.isKeyPressed(\"d\")) inputDirection.x += 1;\n\n    if (inputDirection.length() > 0) {\n      //normalize direction\n      inputDirection.applyQuaternion(objects.player.quaternion);\n      inputDirection.normalize();\n\n      //accelerate towards the direction\n      state.velocity.add(\n        inputDirection.multiplyScalar(\n          PLAYER_CONSTANTS.MOVEMENT_ACCELERATION * deltaTime\n        )\n      );\n      //ensure the velocity doesn't go over the threshold\n      state.velocity.clampLength(0, PLAYER_CONSTANTS.MAX_VELOCITY);\n    } else if (inputDirection.length() == 0 && state.velocity.length() > 0) {\n      const decay = Math.exp(-FRICTION * deltaTime);\n      state.velocity.multiplyScalar(decay);\n\n      if (state.velocity.lengthSq() < VELOCITY_DEADZONE * VELOCITY_DEADZONE) {\n        state.velocity.set(0, 0, 0);\n      }\n    }\n\n    objects.player.position.add(state.velocity);\n  };\n\n  const updateControllers = (deltaTime: number) => {\n    updateMouse(controllers.input.mouse);\n    updateKeyboard(controllers.input.keyboard, deltaTime);\n  };\n\n  const update = (deltaTime: number) => {\n    updateControllers(deltaTime);\n\n    controllers.fsm.update(deltaTime);\n\n    return {\n      position: objects.player?.position ?? new Vector3(0, 0, 0),\n      rotation: objects.player?.rotation ?? new Euler(0, 0, 0, \"XYZ\"),\n      rotationDelta: state.rotationApplied,\n    };\n  };\n\n  const activate = () => {\n    // objects.playerRoot.rotation.set(0,0,0,'XYZ')\n  };\n\n  const deactivate = () => {};\n\n  const unmount = () => {\n    try {\n      //objects.playerRoot.clear();\n    } catch (err) {\n      console.error(`Error while destroy player ${err}`);\n    }\n  };\n\n  return {\n    mount: mount,\n    activate: activate,\n    deactivate: deactivate,\n    update: update,\n    unmount: unmount,\n  };\n};\n"]}