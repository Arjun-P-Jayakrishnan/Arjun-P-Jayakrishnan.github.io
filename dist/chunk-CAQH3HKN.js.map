{"version":3,"sources":["../src/core/loader/loader.ts"],"names":["createLoader","context","scene","renderer","loaderEventBus","globalState","manager","LoadingManager","plugins","_configureLoadingManager","url","itemsLoaded","itemsTotal","_configurePlugins","meshes","animations","hdr","createMeshLoader","createHDRLoader","createFBXLoader","assets","processPipelineDebugger","promises","plugin"],"mappings":"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","file":"chunk-CAQH3HKN.js","sourcesContent":["import { LoadingManager, Scene, WebGLRenderer } from \"three\";\nimport { createHDRLoader } from \"./file_type_plugins/hdr_loader\";\nimport { createMeshLoader } from \"./file_type_plugins/mesh_loader\";\nimport { AssetMetaData, LoaderPlugin } from \"./loaderPlugins\";\nimport { LoadingEvents } from \"@managers/events/eventType\";\nimport { createEventBus } from \"@managers/events/eventBus\";\nimport { GlobalState } from \"@managers/state/globalState\";\nimport { LoadingContext } from \"@managers/state/globalStateData\";\nimport { processPipelineDebugger } from \"debug/debugger\";\nimport { createFBXLoader } from \"./file_type_plugins/fbx_loader\";\n\nexport interface LoadOptions {\n  meshesMetaData: AssetMetaData[];\n  hdrMetaData?: AssetMetaData;\n  animationsMetaData:AssetMetaData[];\n}\n\nexport interface LoaderContext {\n  scene: Scene;\n  renderer: WebGLRenderer;\n  loaderEventBus: ReturnType<typeof createEventBus<LoadingEvents>>;\n  globalState: GlobalState;\n}\n\nexport interface Loader {\n  configure: () => void;\n  load: (assets:LoadOptions) => Promise<{\n    success: string[];\n    error: string[];\n  }>;\n  dispose: () => void;\n}\n/**\n * @description creates a loader with the given settings\n * @param options options to change loader settings\n * @param context global context with references\n * @returns Loader\n */\nexport const createLoader = (\n  context: LoaderContext\n): Loader => {\n  const { scene, renderer, loaderEventBus, globalState } = context;\n  \n\n  const manager: LoadingManager = new LoadingManager();\n  let plugins: LoaderPlugin[] = [];\n\n  /**\n   * @description attaches the event bus for listening to loading changes\n   */\n  const _configureLoadingManager = () => {\n    manager.onStart = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:start\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      globalState.setState({\n        loading: {\n          active: true,\n          progress: 0,\n        } as LoadingContext,\n      });\n    };\n\n    manager.onProgress = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:progress\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      globalState.setState({\n        loading: {\n          active: true,\n          progress: itemsLoaded / itemsTotal,\n        } as LoadingContext,\n      });\n    };\n\n    manager.onLoad = () => {\n      loaderEventBus.emit({\n        type: \"load:complete\",\n      });\n    };\n\n    manager.onError = (url) => {\n      loaderEventBus.emit({\n        type: \"load:error\",\n        url: url,\n      });\n    };\n  };\n\n  /**\n   * @description create necessary loaders\n   */\n  const _configurePlugins = (meshes:AssetMetaData[],animations:AssetMetaData[],hdr?:AssetMetaData) => {\n    if (meshes.length > 0) {\n      plugins.push(\n        createMeshLoader({\n          assets: meshes,\n          scene: scene,\n          loadingManager: manager,\n          loadingEventBus: loaderEventBus,\n        })\n      );\n    }\n\n    if (hdr !== undefined && hdr !== null) {\n      plugins.push(\n        createHDRLoader({\n          asset: hdr,\n          scene: scene,\n          renderer: renderer,\n          loadingManager: manager,\n          loadingEventBus: loaderEventBus,\n        })\n      );\n    }\n    if(animations.length>0){\n      plugins.push(\n        createFBXLoader({\n          assets:animations,\n          scene:scene,\n          loadingManager:manager,\n          loadingEventBus:loaderEventBus,\n        })\n      )\n    }\n  };\n\n  /**\n   * @description configuration\n   */\n  const _configure = () => {\n    _configureLoadingManager();\n   \n  };\n\n  /**\n   * @description load all types of assets\n   */\n  const load = async (assets:LoadOptions): Promise<{ success: []; error: [] }> => {\n    processPipelineDebugger.onInit(`loading the models ${JSON.stringify(assets)}`)\n\n    const promises: Promise<void>[] = [];\n     _configurePlugins(assets.meshesMetaData,assets.animationsMetaData,assets.hdrMetaData,);\n\n    plugins.forEach((plugin) => {\n      promises.push(plugin.load());\n    });\n\n    await Promise.allSettled(promises);\n\n    plugins=[];\n\n    processPipelineDebugger.onInit(`loaded models i guess`)\n\n    return {\n      success: [],\n      error: [],\n    };\n  };\n\n  const dispose = () => {\n    plugins.forEach((plugin) => {\n      plugin.dispose?.();\n    });\n  };\n\n  return {\n    configure: _configure,\n    load: load,\n    dispose: dispose,\n  };\n};\n"]}