{"version":3,"sources":["../src/engine/managers/animation/FSM.ts"],"names":["AnimationFSM","initialState","stateDefs","s","params","state","t","next","name"],"mappings":"AAwDO,IAAMA,CAAAA,CAAN,KAAyC,CAe9C,WAAA,CAAYC,CAAAA,CAAsBC,CAAAA,CAAuB,CACvD,IAAA,CAAK,MAAA,CAAS,IAAI,GAAA,CAAIA,CAAAA,CAAU,GAAA,CAAKC,GAAM,CAACA,CAAAA,CAAE,IAAA,CAAMA,CAAC,CAAC,CAAC,CAAA,CACvD,IAAA,CAAK,YAAA,CAAeF,EACtB,CAOA,IAAA,CAAKG,CAAAA,CAA6B,CAChC,IAAMC,CAAAA,CAAQ,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,IAAA,CAAK,YAAY,CAAA,CAE/C,GADA,OAAA,CAAQ,GAAA,CAAI,2BAAA,CAA6BA,CAAK,CAAA,CAC1C,CAAA,CAACA,GAAO,WAAA,CAAA,CAEZ,IAAA,IAAWC,CAAAA,IAAKD,CAAAA,CAAM,WAAA,CAEpB,GADA,OAAA,CAAQ,GAAA,CAAI,uBAAA,CAAyBC,CAAAA,CAAE,SAAA,CAAUF,CAAM,CAAC,CAAA,CACpDE,EAAE,SAAA,CAAUF,CAAM,CAAA,CAAG,CACvB,IAAA,CAAK,WAAA,CAAYE,CAAAA,CAAE,EAAE,CAAA,CACrB,KACF,CAAA,CAEJ,CAMQ,WAAA,CAAYC,CAAAA,CAAc,CAChC,GAAI,IAAA,CAAK,YAAA,GAAiBA,CAAAA,CAAM,OAEhB,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,IAAA,CAAK,YAAY,CAAA,EACxC,MAAA,IAAS,CAElB,IAAA,CAAK,cAAgB,IAAA,CAAK,YAAA,CAC1B,IAAA,CAAK,YAAA,CAAeA,CAAAA,CAEF,IAAA,CAAK,MAAA,CAAO,GAAA,CAAI,IAAA,CAAK,YAAY,CAAA,EACxC,OAAA,KACb,CAMA,kBAAuC,CACrC,OAAO,IAAA,CAAK,aACd,CAOA,SAAA,CAAUC,CAAAA,CAAuB,CAC/B,OAAO,IAAA,CAAK,YAAA,GAAiBA,CAC/B,CACF","file":"chunk-DEUTJOB7.js","sourcesContent":["import { AnimationParameters } from \"./Parameters\";\n\n/**\n * Interface for any FSM Runtime.\n */\nexport interface FSMRuntime {\n  /** Current active state name */\n  currentState: string;\n\n  /**\n   * Evaluate transitions and update the current state.\n   * @param params - The animation parameters used to check transition conditions.\n   */\n  tick(params: AnimationParameters): void;\n\n  /** Get the previous state, if any */\n  getPreviousState(): string | undefined;\n\n  /**\n   * Check if FSM is currently in a specific state\n   * @param name - State name to check\n   */\n  isInState(name: string): boolean;\n}\n\n/** Condition function used to evaluate a transition */\nexport type TransitionCondition = (params: AnimationParameters) => boolean;\n\n/** Represents a transition from one state to another */\nexport interface Transition {\n  /** Target state name */\n  to: string;\n\n  /** Condition function to trigger this transition */\n  condition: TransitionCondition;\n}\n\n/** Represents a single FSM state */\nexport interface FSMState {\n  /** Unique state name */\n  name: string;\n\n  /** Optional transitions from this state */\n  transitions?: Transition[];\n\n  /** Optional hook called when entering this state */\n  onEnter?: () => void;\n\n  /** Optional hook called when exiting this state */\n  onExit?: () => void;\n}\n\n/**\n * Animation FSM implementation of FSMRuntime.\n * Handles current state, transitions, and entry/exit hooks.\n */\nexport class AnimationFSM implements FSMRuntime {\n  /** Map of state name to FSMState */\n  private states: Map<string, FSMState>;\n\n  /** Previously active state name */\n  private previousState?: string;\n\n  /** Currently active state name */\n  public currentState: string;\n\n  /**\n   * Create a new AnimationFSM instance.\n   * @param initialState - Name of the initial state\n   * @param stateDefs - Array of FSM states\n   */\n  constructor(initialState: string, stateDefs: FSMState[]) {\n    this.states = new Map(stateDefs.map((s) => [s.name, s]));\n    this.currentState = initialState;\n  }\n\n  /**\n   * Evaluate transitions based on animation parameters.\n   * Updates the current state if a transition condition is met.\n   * @param params - Animation parameters used to evaluate transitions\n   */\n  tick(params: AnimationParameters) {\n    const state = this.states.get(this.currentState);\n    console.log(\"[tick:AnimationFSM] state\", state);\n    if (!state?.transitions) return;\n\n    for (const t of state.transitions) {\n      console.log(\"[tick:AniamtionFSM] t\", t.condition(params));\n      if (t.condition(params)) {\n        this.changeState(t.to);\n        break; // only first valid transition per tick\n      }\n    }\n  }\n\n  /**\n   * Change the current state and call exit/enter hooks.\n   * @param next - Name of the next state\n   */\n  private changeState(next: string) {\n    if (this.currentState === next) return;\n\n    const current = this.states.get(this.currentState);\n    current?.onExit?.();\n\n    this.previousState = this.currentState;\n    this.currentState = next;\n\n    const nextState = this.states.get(this.currentState);\n    nextState?.onEnter?.();\n  }\n\n  /**\n   * Get the previously active state.\n   * @returns Name of the previous state or undefined\n   */\n  getPreviousState(): string | undefined {\n    return this.previousState;\n  }\n\n  /**\n   * Check if the FSM is currently in a specific state.\n   * @param name - State name to check\n   * @returns True if the FSM is in the specified state\n   */\n  isInState(name: string): boolean {\n    return this.currentState === name;\n  }\n}\n"]}