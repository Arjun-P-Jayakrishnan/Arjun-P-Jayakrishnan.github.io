{"version":3,"sources":["../src/utils/state/observable.ts"],"sourcesContent":["/**\r\n * Properties of observable\r\n */\r\nexport interface ObservableProps<T> {\r\n  initial: T;\r\n}\r\n\r\n/**\r\n * Observable methods\r\n */\r\nexport interface Observable<T> {\r\n  /**\r\n   *\r\n   * @description gets current state\r\n   * @returns currents state\r\n   */\r\n  getValue: () => T;\r\n  /**\r\n   * @description changes the current state to new state and notifies all listeners\r\n   * @param value the new state\r\n   */\r\n  setValue: (value: T) => void;\r\n  /**\r\n   * @description allows to look for changes\r\n   * @param fn callback function to be run when state changes\r\n   * @returns un subscribe function reference to unsubscribe when no longer needed\r\n   */\r\n  subscribeToChanges: (fn: (val: T) => void) => () => void;\r\n  /**\r\n   * @description allows clean up of unsubscribed functions\r\n   */\r\n  dispose: () => void;\r\n}\r\n\r\n/**\r\n * @description creates an observable for the given type with a initial state\r\n * @param props initial state of observable\r\n * @returns observable\r\n */\r\nexport const createObservable = <T>(\r\n  props: ObservableProps<T>\r\n): Observable<T> => {\r\n  let value = props.initial;\r\n  const listeners: Set<(val: T) => void> = new Set();\r\n  let scheduled: boolean = false;\r\n\r\n  /**\r\n   * @description changes the state to new state and notifies all listeners\r\n   * @param _value the new state\r\n   */\r\n  const setValue = (_value: T) => {\r\n    if (value === _value) {\r\n      return;\r\n    }\r\n    value = _value;\r\n    if (!scheduled) {\r\n      setTimeout(() => {\r\n        listeners.forEach((fn) => fn(_value));\r\n      }, 0);\r\n    }\r\n  };\r\n\r\n  /**\r\n   * @description gets the data of current state\r\n   * @returns the current state\r\n   */\r\n  const _getValue = () => {\r\n    return value;\r\n  };\r\n\r\n  /**\r\n   * @description subscribe to state changes\r\n   * @param fn the callback function when the state changes\r\n   * @returns un subscribe function to clean up\r\n   */\r\n  const subscribeToChanges = (fn: (val: T) => void) => {\r\n    listeners.add(fn);\r\n    return () => {\r\n      listeners.delete(fn);\r\n    };\r\n  };\r\n\r\n  /**\r\n   * @description clears the set so that there are no memory leaks\r\n   */\r\n  const dispose = () => {\r\n    listeners.clear();\r\n  };\r\n\r\n  return Object.freeze({\r\n    getValue: _getValue,\r\n    setValue: setValue,\r\n    subscribeToChanges: subscribeToChanges,\r\n    dispose: dispose,\r\n  });\r\n};\r\n"],"mappings":";AAuCO,IAAM,mBAAmB,CAC9B,UACkB;AAClB,MAAI,QAAQ,MAAM;AAClB,QAAM,YAAmC,oBAAI,IAAI;AACjD,MAAI,YAAqB;AAMzB,QAAM,WAAW,CAAC,WAAc;AAC9B,QAAI,UAAU,QAAQ;AACpB;AAAA,IACF;AACA,YAAQ;AACR,QAAI,CAAC,WAAW;AACd,iBAAW,MAAM;AACf,kBAAU,QAAQ,CAAC,OAAO,GAAG,MAAM,CAAC;AAAA,MACtC,GAAG,CAAC;AAAA,IACN;AAAA,EACF;AAMA,QAAM,YAAY,MAAM;AACtB,WAAO;AAAA,EACT;AAOA,QAAM,qBAAqB,CAAC,OAAyB;AACnD,cAAU,IAAI,EAAE;AAChB,WAAO,MAAM;AACX,gBAAU,OAAO,EAAE;AAAA,IACrB;AAAA,EACF;AAKA,QAAM,UAAU,MAAM;AACpB,cAAU,MAAM;AAAA,EAClB;AAEA,SAAO,OAAO,OAAO;AAAA,IACnB,UAAU;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACH;","names":[]}