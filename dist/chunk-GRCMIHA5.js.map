{"version":3,"sources":["../src/gameplay/rooms/navigation/camera.ts"],"names":["TPV_CONFIG","tempPosition","Vector3","tempOffset","tempLookTarget","clampRotation","yaw","pitch","MathUtils","computeThirdPersonOffset","spherical","lerpVector","from","to","alpha","createCameraManager","camera","isThirdPerson","state","Spherical","setCamera","mode","mount","activate","updateRotation","delta","clamped","updateThirdPerson","info","updateFirstPerson","playerPos"],"mappings":"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","file":"chunk-GRCMIHA5.js","sourcesContent":["import { Euler, MathUtils, PerspectiveCamera, Spherical, Vector3 } from \"three\";\nimport { GenericLifeCycle } from \"types/rooms.types\";\n\nexport type CameraMode = \"firstPerson\" | \"thirdPerson\";\n\nexport interface CameraProps {\n  /**Main Camera */\n  camera: PerspectiveCamera;\n}\n\n/** Contains the Updated info about player */\nexport type UpdatedInfo = {\n  playerPosition: Vector3;\n  rotationDelta: { yaw: number; pitch: number };\n};\n\n/** Controls to manage camera */\nexport interface CameraManager extends GenericLifeCycle {\n  /** Updates the camera to look the player */\n  update: (info: UpdatedInfo) => { rotation: Euler };\n\n  /**sets the mode of camera */\n  setMode: (mode: CameraMode) => void;\n}\n\n//Third Person Config\nconst TPV_CONFIG = {\n  DISTANCE: 3,\n  HEIGHT_OFFSET: 2,\n  PITCH_MIN: 0,\n  PITH_MAX: Math.PI / 2,\n  SMOOTHING: 0.1,\n} as const;\n\n//Temporary Variables\n\nlet tempPosition = new Vector3(0, 0, 0);\nlet tempOffset = new Vector3(0, 0, 0);\nlet tempLookTarget = new Vector3(0, 0, 0);\n\n/**\n *\n * @param yaw the yaw angle\n * @param pitch the pitch angle\n * @returns restricted angles\n */\nfunction clampRotation(\n  yaw: number,\n  pitch: number\n): { yaw: number; pitch: number } {\n  return {\n    yaw: MathUtils.euclideanModulo(yaw, Math.PI * 2),\n    pitch: MathUtils.clamp(pitch, TPV_CONFIG.PITCH_MIN, TPV_CONFIG.PITH_MAX),\n  };\n}\n\n/**\n *\n * @param spherical the spherical coordinates\n * @returns the Vector based on spherical coordinates\n */\nfunction computeThirdPersonOffset(spherical: Spherical): Vector3 {\n  tempOffset.set(0, 0, 0);\n  tempOffset.setFromSpherical(spherical);\n  tempOffset.y += TPV_CONFIG.HEIGHT_OFFSET;\n\n  return tempOffset;\n}\n\n/**\n * Smoothly interpolate value between from and to vectors based on alpha\n */\nfunction lerpVector(from: Vector3, to: Vector3, alpha: number) {\n  return from.lerp(to, alpha);\n}\n\ninterface InternalState {\n  mode: CameraMode;\n  rotation: { yaw: number; pitch: number };\n  spherical: Spherical;\n}\n\nexport const createCameraManager = ({ camera }: CameraProps): CameraManager => {\n  let isThirdPerson: boolean = true;\n  let state: InternalState = {\n    mode: \"thirdPerson\",\n    rotation: { pitch: Math.PI / 2, yaw: 0 },\n    spherical: new Spherical(TPV_CONFIG.DISTANCE, Math.PI / 2, 0),\n  };\n\n  const setCamera = (mode: CameraMode) => {\n    state.mode = mode;\n  };\n\n  const mount = () => {};\n\n  const activate = () => {\n    camera.position.set(1, 2, 3);\n  };\n\n  /**\n   *\n   * @param yaw\n   * @param pitch\n   */\n  const updateRotation = (delta: { yaw: number; pitch: number }) => {\n    state.rotation.yaw += delta.yaw;\n    state.rotation.pitch += delta.pitch;\n\n    const clamped = clampRotation(state.rotation.yaw, state.rotation.pitch);\n    state.rotation.yaw = clamped.yaw;\n    state.rotation.pitch = clamped.pitch;\n  };\n\n  const updateThirdPerson = (info: UpdatedInfo) => {\n    state.spherical.theta = state.rotation.yaw;\n    state.spherical.phi = state.rotation.pitch;\n\n    //Calculate offset\n    tempOffset.copy(computeThirdPersonOffset(state.spherical));\n\n    //Calculate target position and camera lerp smoothly\n    tempPosition.copy(info.playerPosition).add(tempOffset);\n    camera.position.copy(\n      lerpVector(camera.position, tempPosition, TPV_CONFIG.SMOOTHING)\n    );\n\n    tempLookTarget.copy(info.playerPosition);\n    tempLookTarget.y += TPV_CONFIG.HEIGHT_OFFSET;\n    camera.lookAt(tempLookTarget);\n  };\n\n  const updateFirstPerson = (playerPos: Vector3) => {\n    camera.position.copy(playerPos);\n    camera.rotation.set(state.rotation.pitch, state.rotation.yaw, 0);\n  };\n\n  const update = (info: UpdatedInfo): { rotation: Euler } => {\n    updateRotation(info.rotationDelta);\n\n    if (state.mode === \"thirdPerson\") {\n      updateThirdPerson(info);\n    } else {\n      updateFirstPerson(info.playerPosition);\n    }\n\n    return {\n      rotation: camera.rotation,\n    };\n  };\n\n  const deactivate = () => {};\n\n  const unmount = () => {};\n\n  return {\n    setMode: setCamera,\n    update: update,\n    mount: mount,\n    activate: activate,\n    deactivate: deactivate,\n    unmount: unmount,\n  };\n};\n"]}