{"version":3,"sources":["../src/gameplay/rooms/navigation/player.ts"],"names":["PLAYER_CONSTANTS","createPlayer","reference","storage","InputManager","controllers","state","Vector3","tempData","objects","mount","playerRoot","player","animations","mixer","AnimationMixer","animationController","createAnimationController","fsmController","createFSMController","err","updateMouse","mouse","updateKeyboard","keyboard","deltaTime","FRICTION","VELOCITY_DEADZONE","inputDirection","decay","updateControllers","Euler"],"mappings":"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","file":"chunk-N2KZDBMS.js","sourcesContent":["import { InputManager } from \"engine/managers/InputManager\";\nimport { GlobalStorageManager } from \"engine/managers/storage/storageTypes\";\nimport {\n  AnimationController,\n  createAnimationController,\n} from \"gameplay/modules/animation\";\nimport {\n  createFSMController,\n  FSMController,\n} from \"gameplay/modules/fsm/player\";\nimport { KeyboardInput } from \"plugins/input/keyboard\";\nimport { MouseInput } from \"plugins/input/mouse\";\nimport { AnimationMixer, Euler, Object3D, Vector3 } from \"three\";\nimport { GenericLifeCycle, ModelIdentifier } from \"types/rooms.types\";\n\nexport interface PlayerProps {\n  reference: ModelIdentifier;\n  storage: GlobalStorageManager;\n  InputManager: InputManager;\n}\n\nexport interface Player extends GenericLifeCycle {\n  /** Update based on controller input */\n  update: (deltaTime: number) => {\n    position: Vector3;\n    rotation: Euler;\n    rotationDelta: { yaw: number; pitch: number };\n  };\n}\n\ninterface PlayerState {\n  direction: Vector3;\n  velocity: Vector3;\n  rotationApplied: {\n    yaw: number;\n    pitch: number;\n  };\n}\n\ninterface Controllers {\n  input: {\n    mouse: Nullable<MouseInput>;\n    keyboard: Nullable<KeyboardInput>;\n  };\n  animation: AnimationController;\n  fsm: FSMController;\n}\n\ninterface ObjectReferences {\n  player: Nullable<Object3D>;\n}\n\nconst PLAYER_CONSTANTS = {\n  MOVEMENT_ACCELERATION: 0.05,\n  MAX_VELOCITY: 0.05,\n};\n\ninterface TempData {\n  inputDirection: Vector3;\n}\n\nexport const createPlayer = ({\n  reference,\n  storage,\n  InputManager,\n}: PlayerProps): Player => {\n  let controllers: Controllers;\n\n  let state: PlayerState = {\n    direction: new Vector3(0, 0, -1),\n    velocity: new Vector3(0, 0, 0),\n    rotationApplied: {\n      pitch: 0,\n      yaw: 0,\n    },\n  };\n  let tempData: TempData = {\n    inputDirection: new Vector3(0, 0, 0),\n  };\n\n  let objects: ObjectReferences = { player: null };\n\n  const mount = () => {\n    try {\n      const playerRoot = storage\n        .getStorage(\"model\")\n        .retrieve(reference.storageId);\n\n      if (!playerRoot) {\n        throw new Error(\n          `player doesn't exist for the id ${reference.storageId}`\n        );\n      }\n      const player = playerRoot?.groups;\n      const animations = playerRoot?.animations;\n\n      /**Animation */\n      const mixer = new AnimationMixer(player);\n      const animationController = createAnimationController({\n        mixer: mixer,\n        actions: {\n          Idle: mixer.clipAction(animations[0]),\n          Walk: mixer.clipAction(animations[3]),\n          Run: mixer.clipAction(animations[1]),\n        },\n        crossFadeDuration: 0.3,\n      });\n\n      const fsmController = createFSMController({\n        animationController: animationController,\n        inputs: InputManager,\n      });\n      fsmController.mount();\n\n      objects = {\n        player: player,\n      };\n\n      controllers = {\n        input: {\n          mouse: InputManager.getController(\"mouse\"),\n          keyboard: InputManager.getController(\"keyboard\"),\n        },\n        animation: animationController,\n        fsm: fsmController,\n      };\n    } catch (err) {\n      console.error(`Player mesh cant be obtained :${err}`);\n    }\n  };\n\n  const updateMouse = (mouse: Nullable<MouseInput>) => {\n    if (!mouse || !objects.player!) return;\n\n    state.rotationApplied = mouse.getRotation();\n    objects.player.rotation.y += state.rotationApplied.yaw;\n  };\n\n  const updateKeyboard = (\n    keyboard: Nullable<KeyboardInput>,\n    deltaTime: number\n  ) => {\n    if (!keyboard || !objects.player) return;\n    const FRICTION = 5.0;\n    const VELOCITY_DEADZONE = 0.001;\n\n    const { inputDirection } = tempData;\n    inputDirection.set(0, 0, 0);\n\n    if (keyboard.isKeyPressed(\"w\")) inputDirection.z -= 1;\n    if (keyboard.isKeyPressed(\"s\")) inputDirection.z += 1;\n    if (keyboard.isKeyPressed(\"a\")) inputDirection.x -= 1;\n    if (keyboard.isKeyPressed(\"d\")) inputDirection.x += 1;\n\n    if (inputDirection.length() > 0) {\n      //normalize direction\n      inputDirection.applyQuaternion(objects.player.quaternion);\n      inputDirection.normalize();\n\n      //accelerate towards the direction\n      state.velocity.add(\n        inputDirection.multiplyScalar(\n          PLAYER_CONSTANTS.MOVEMENT_ACCELERATION * deltaTime\n        )\n      );\n      //ensure the velocity doesn't go over the threshold\n      state.velocity.clampLength(0, PLAYER_CONSTANTS.MAX_VELOCITY);\n    } else if (inputDirection.length() == 0 && state.velocity.length() > 0) {\n      const decay = Math.exp(-FRICTION * deltaTime);\n      state.velocity.multiplyScalar(decay);\n\n      if (state.velocity.lengthSq() < VELOCITY_DEADZONE * VELOCITY_DEADZONE) {\n        state.velocity.set(0, 0, 0);\n      }\n    }\n\n    objects.player.position.add(state.velocity);\n  };\n\n  const updateControllers = (deltaTime: number) => {\n    updateMouse(controllers.input.mouse);\n    updateKeyboard(controllers.input.keyboard, deltaTime);\n  };\n\n  const update = (deltaTime: number) => {\n    updateControllers(deltaTime);\n\n    controllers.fsm.update(deltaTime);\n\n    return {\n      position: objects.player?.position ?? new Vector3(0, 0, 0),\n      rotation: objects.player?.rotation ?? new Euler(0, 0, 0, \"XYZ\"),\n      rotationDelta: state.rotationApplied,\n    };\n  };\n\n  const activate = () => {\n    // objects.playerRoot.rotation.set(0,0,0,'XYZ')\n  };\n\n  const deactivate = () => {};\n\n  const unmount = () => {\n    try {\n      //objects.playerRoot.clear();\n    } catch (err) {\n      console.error(`Error while destroy player ${err}`);\n    }\n  };\n\n  return {\n    mount: mount,\n    activate: activate,\n    deactivate: deactivate,\n    update: update,\n    unmount: unmount,\n  };\n};\n"]}