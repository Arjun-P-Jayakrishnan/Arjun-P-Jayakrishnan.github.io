{"version":3,"sources":["../../../../src/engine/core/events/eventBus.ts","../../../../src/engine/core/events/EventBusManager.ts"],"names":["createEventBus","listeners","_on","type","callback","_off","event","wrapper","createEventBusManager","loadingBus","displayBus","debugBus","switchTabBus","viewBus"],"mappings":"AA+CO,IAAMA,CAAiB,CAAA,IAA+C,CAI3E,IAAMC,CAAY,CAAA,IAAI,GAOhBC,CAAAA,CAAAA,CAAM,CACVC,CAAAA,CACAC,CACG,GAAA,CACEH,EAAU,GAAIE,CAAAA,CAAI,CACrBF,EAAAA,CAAAA,CAAU,GAAIE,CAAAA,CAAAA,CAAM,IAAI,GAAK,CAG/BF,CAAAA,CAAAA,CAAU,GAAIE,CAAAA,CAAI,CAAG,CAAA,GAAA,CAAIC,CAAuB,EAClD,EAOMC,CAAO,CAAA,CACXF,CACAC,CAAAA,CAAAA,GACG,CACHH,CAAAA,CAAU,GAAIE,CAAAA,CAAI,CAAG,EAAA,MAAA,CAAOC,CAAuB,EACrD,CAoCA,CAAA,OAAO,MAAO,CAAA,MAAA,CAAO,CACnB,EAAIF,CAAAA,CAAAA,CACJ,GAAKG,CAAAA,CAAAA,CACL,IAjCaC,CAAAA,CAAAA,EAAa,CAC1BL,CAAAA,CAAU,GAAIK,CAAAA,CAAAA,CAAM,IAAI,CAAA,EAAG,OAASF,CAAAA,CAAAA,EAAa,CAC/CA,CAAAA,CAASE,CAAK,EAChB,CAAC,EACH,CAAA,CA8BE,KAzBa,CAAA,IAAM,CACnBL,CAAAA,CAAU,KAAM,GAClB,CAwBE,CAAA,IAAA,CAjBY,CACZE,CAAAA,CACAC,CACG,GAAA,CACH,IAAMG,CAAWD,CAAAA,CAAAA,EAAmC,CAClDF,CAAAA,CAASE,CAAK,CAAA,CACdD,CAAKF,CAAAA,CAAAA,CAAMI,CAAO,EACpB,CAEAL,CAAAA,CAAAA,CAAIC,CAAMI,CAAAA,CAAO,EACnB,CAQA,CAAC,CACH,CAAA,CCtFMC,IAAAA,CAAAA,CAAwB,IAAuB,CACnD,IAAMC,CAAAA,CAAaT,CAA8B,EAAA,CAC3CU,CAAaV,CAAAA,CAAAA,EACbW,CAAAA,CAAAA,CAAWX,CAA4B,EAAA,CACvCY,EAAeZ,CAAgC,EAAA,CAC/Ca,CAAUb,CAAAA,CAAAA,EAEhB,CAAA,OAAO,CACL,UAAA,CAAYS,CACZ,CAAA,UAAA,CAAYC,CACZ,CAAA,QAAA,CAAUC,CACV,CAAA,YAAA,CAAcC,CACd,CAAA,OAAA,CAASC,CACX,CACF","file":"EventBusManager.js","sourcesContent":["//A callback that handles specific event object of type T.\nexport type Listener<T> = (event: T) => void;\n\nexport interface EventBus<T extends { type: string }> {\n  /**\n   * @description subscribe to event\n   * @param type the event type\n   * @param callback the listener callback when event is triggered\n   */\n  on: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n\n  /**\n   * @description un-subscribe to event\n   * @param type event type to be un subscribe\n   * @param callback call back that has to be removed\n   */\n  off: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n\n  /**\n   * @description emits the event\n   * @param event event that must be emitted\n   */\n  emit: (event: T) => void;\n\n  /**\n   * @description clears all the listeners\n   */\n  clear: () => void;\n\n  once: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n}\n\n/**\n * @description creates an event Bus for a custom event type\n *\n * Note: event must be an object with a parameter {type:string,.....}\n * @returns\n */\nexport const createEventBus = <T extends { type: string }>(): EventBus<T> => {\n  /**\n   *  \"start\" -- its callbacks\n   */\n  const listeners = new Map<T[\"type\"], Set<Listener<T>>>();\n\n  /**\n   * @description register a listener for a specfic event type\n   * @param type event type\n   * @param callback extracts only the ones with the event type\n   */\n  const _on = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    if (!listeners.has(type)) {\n      listeners.set(type, new Set());\n    }\n\n    listeners.get(type)!.add(callback as Listener<T>);\n  };\n\n  /**\n   * @description un subscribe from the event\n   * @param type the event type\n   * @param callback the callback that has to be removed\n   */\n  const _off = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    listeners.get(type)?.delete(callback as Listener<T>);\n  };\n\n  /**\n   * @description similar in function to notify all\n   * @param event event that has to be triggered\n   */\n  const _emit = (event: T) => {\n    listeners.get(event.type)?.forEach((callback) => {\n      callback(event);\n    });\n  };\n\n  /**\n   * @description clean up function\n   */\n  const _clear = () => {\n    listeners.clear();\n  };\n\n  /**\n   * @description calls the function once\n   * @param type event type\n   * @param callback callback to be executed\n   */\n  const _once = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    const wrapper = (event: Extract<T, { type: K }>) => {\n      callback(event);\n      _off(type, wrapper);\n    };\n\n    _on(type, wrapper);\n  };\n\n  return Object.freeze({\n    on: _on,\n    off: _off,\n    emit: _emit,\n    clear: _clear,\n    once: _once,\n  });\n};\n","import {\n  DebugEvents,\n  LoadingEvents,\n  NavigationEvents,\n  SwitchTabEvents,\n  ViewEvents,\n} from \"../../../types/eventType\";\nimport { createEventBus, EventBus } from \"./eventBus\";\n\ninterface EventBusManager {\n  /**\n   * @description Event Bus for loading related events\n   */\n  loadingBus: EventBus<LoadingEvents>;\n  /**\n   * @description Event bus for display related events\n   */\n  displayBus: EventBus<NavigationEvents>;\n  /**\n   * @description Event bus for debugging\n   */\n  debugBus: EventBus<DebugEvents>;\n  /**\n   * @description Event Bus for pre-fetching data and tab switch\n   */\n  switchTabBus: EventBus<SwitchTabEvents>;\n  /**\n   *@description show delayed events\n   */\n  viewBus: EventBus<ViewEvents>;\n}\n\n/**\n * @description creates anf manages event buses designed for various tasks\n * @returns\n */\nconst createEventBusManager = (): EventBusManager => {\n  const loadingBus = createEventBus<LoadingEvents>();\n  const displayBus = createEventBus<NavigationEvents>();\n  const debugBus = createEventBus<DebugEvents>();\n  const switchTabBus = createEventBus<SwitchTabEvents>();\n  const viewBus = createEventBus<ViewEvents>();\n\n  return {\n    loadingBus: loadingBus,\n    displayBus: displayBus,\n    debugBus: debugBus,\n    switchTabBus: switchTabBus,\n    viewBus: viewBus,\n  };\n};\n\nexport { createEventBusManager };\nexport type { EventBusManager };\n"]}