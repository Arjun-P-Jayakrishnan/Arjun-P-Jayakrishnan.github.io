{"version":3,"sources":["../../../../src/engine/core/events/eventBus.ts"],"names":["createEventBus","listeners","_on","type","callback","_off","event","wrapper"],"mappings":"AA+CaA,IAAAA,CAAAA,CAAiB,IAA+C,CAI3E,IAAMC,EAAY,IAAI,GAAA,CAOhBC,EAAM,CACVC,CAAAA,CACAC,IACG,CACEH,CAAAA,CAAU,IAAIE,CAAI,CAAA,EACrBF,EAAU,GAAIE,CAAAA,CAAAA,CAAM,IAAI,GAAK,CAG/BF,CAAAA,CAAAA,CAAU,IAAIE,CAAI,CAAA,CAAG,IAAIC,CAAuB,EAClD,EAOMC,CAAO,CAAA,CACXF,CACAC,CAAAA,CAAAA,GACG,CACHH,CAAAA,CAAU,IAAIE,CAAI,CAAA,EAAG,OAAOC,CAAuB,EACrD,EAoCA,OAAO,MAAA,CAAO,MAAO,CAAA,CACnB,EAAIF,CAAAA,CAAAA,CACJ,IAAKG,CACL,CAAA,IAAA,CAjCaC,GAAa,CAC1BL,CAAAA,CAAU,IAAIK,CAAM,CAAA,IAAI,GAAG,OAASF,CAAAA,CAAAA,EAAa,CAC/CA,CAASE,CAAAA,CAAK,EAChB,CAAC,EACH,EA8BE,KAzBa,CAAA,IAAM,CACnBL,CAAAA,CAAU,KAAM,GAClB,EAwBE,IAjBY,CAAA,CACZE,EACAC,CACG,GAAA,CACH,IAAMG,CAAWD,CAAAA,CAAAA,EAAmC,CAClDF,CAAAA,CAASE,CAAK,CAAA,CACdD,EAAKF,CAAMI,CAAAA,CAAO,EACpB,CAEAL,CAAAA,CAAAA,CAAIC,EAAMI,CAAO,EACnB,CAQA,CAAC,CACH","file":"eventBus.js","sourcesContent":["//A callback that handles specific event object of type T.\nexport type Listener<T> = (event: T) => void;\n\nexport interface EventBus<T extends { type: string }> {\n  /**\n   * @description subscribe to event\n   * @param type the event type\n   * @param callback the listener callback when event is triggered\n   */\n  on: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n\n  /**\n   * @description un-subscribe to event\n   * @param type event type to be un subscribe\n   * @param callback call back that has to be removed\n   */\n  off: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n\n  /**\n   * @description emits the event\n   * @param event event that must be emitted\n   */\n  emit: (event: T) => void;\n\n  /**\n   * @description clears all the listeners\n   */\n  clear: () => void;\n\n  once: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n}\n\n/**\n * @description creates an event Bus for a custom event type\n *\n * Note: event must be an object with a parameter {type:string,.....}\n * @returns\n */\nexport const createEventBus = <T extends { type: string }>(): EventBus<T> => {\n  /**\n   *  \"start\" -- its callbacks\n   */\n  const listeners = new Map<T[\"type\"], Set<Listener<T>>>();\n\n  /**\n   * @description register a listener for a specfic event type\n   * @param type event type\n   * @param callback extracts only the ones with the event type\n   */\n  const _on = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    if (!listeners.has(type)) {\n      listeners.set(type, new Set());\n    }\n\n    listeners.get(type)!.add(callback as Listener<T>);\n  };\n\n  /**\n   * @description un subscribe from the event\n   * @param type the event type\n   * @param callback the callback that has to be removed\n   */\n  const _off = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    listeners.get(type)?.delete(callback as Listener<T>);\n  };\n\n  /**\n   * @description similar in function to notify all\n   * @param event event that has to be triggered\n   */\n  const _emit = (event: T) => {\n    listeners.get(event.type)?.forEach((callback) => {\n      callback(event);\n    });\n  };\n\n  /**\n   * @description clean up function\n   */\n  const _clear = () => {\n    listeners.clear();\n  };\n\n  /**\n   * @description calls the function once\n   * @param type event type\n   * @param callback callback to be executed\n   */\n  const _once = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    const wrapper = (event: Extract<T, { type: K }>) => {\n      callback(event);\n      _off(type, wrapper);\n    };\n\n    _on(type, wrapper);\n  };\n\n  return Object.freeze({\n    on: _on,\n    off: _off,\n    emit: _emit,\n    clear: _clear,\n    once: _once,\n  });\n};\n"]}