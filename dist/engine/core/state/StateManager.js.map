{"version":3,"sources":["../../../../src/engine/core/state/observable.ts","../../../../src/engine/core/state/globalState.ts","../../../../src/engine/core/state/StateManager.ts"],"names":["createObservable","props","value","listeners","scheduled","_value","fn","createGlobalState","map","stateMap","key","observable","state","newState","createGlobalStateManager"],"mappings":"AAuCO,IAAMA,EACXC,CACkB,EAAA,KACdC,CAAQD,CAAAA,CAAAA,CAAM,QACZE,CAAmC,CAAA,IAAI,GACzCC,CA6CJ,OAAO,MAAA,CAAO,OAAO,CACnB,QAAA,CAxBgB,IACTF,CAwBP,CAAA,QAAA,CAzCgBG,CAAc,EAAA,CAC1BH,IAAUG,CAGdH,GAAAA,CAAAA,CAAQG,EAEN,UAAA,CAAW,IAAM,CACfF,CAAAA,CAAU,QAASG,CAAOA,EAAAA,CAAAA,CAAGD,CAAM,CAAC,EACtC,EAAG,CAAC,CAAA,EAER,EAgCE,kBAjB0BC,CAAAA,CAAAA,GAC1BH,CAAU,CAAA,GAAA,CAAIG,CAAE,CACT,CAAA,IAAM,CACXH,CAAU,CAAA,MAAA,CAAOG,CAAE,EACrB,CAAA,CAAA,CAcA,OARc,CAAA,IAAM,CACpBH,CAAU,CAAA,KAAA,GACZ,CAOA,CAAC,CACH,CCvCO,CAAA,IAAMI,CACXC,CAAAA,CAAAA,EACgB,CAChB,IAAMC,CAAAA,CAAc,EAqEpB,CAAA,OAAO,OAAO,MAAO,CAAA,CACnB,QAlEc,IAAM,CACpB,QAAWC,CAAOF,IAAAA,CAAAA,CAAK,CACrB,IAAMG,CAAAA,CAAaX,EAAiB,CAAE,OAAA,CAASQ,CAAIE,CAAAA,CAAG,CAAE,CAAC,CAAA,CACzDD,EAASC,CAAc,CAAA,CAAIC,EAC7B,CACF,CAAA,CA8DE,QAxDe,CAAA,IAAgD,CAC/D,IAAMC,CAAAA,CAAQ,EAEd,CAAA,IAAA,IAAWF,KAAOD,CAChBG,CAAAA,CAAAA,CAAMF,CAAG,CAAA,CAAID,EAASC,CAAG,CAAA,CAAE,UAG7B,CAAA,OAAOE,CACT,CAiDE,CAAA,QAAA,CA1CAC,GACG,CACH,IAAA,IAAWH,KAAOG,CACZJ,CAAAA,CAAAA,CAASC,CAAG,CACdD,EAAAA,CAAAA,CAASC,CAAG,CAAE,CAAA,QAAA,CAASG,CAASH,CAAAA,CAAG,CAAC,EAG1C,CAAA,CAoCE,cA5BAA,CAEOD,EAAAA,CAAAA,CAASC,CAAG,CA2BnB,CAAA,SAAA,CArBgB,CAChBA,CAAAA,CACAJ,IAEOG,CAASC,CAAAA,CAAG,EAAE,kBAAmBJ,CAAAA,CAAE,EAkB1C,OAZc,CAAA,IAAM,CACpB,IAAA,IAAWI,KAAOD,CAChBA,CAAAA,CAAAA,CAASC,CAAG,CAAE,CAAA,OAAA,GAElB,CASA,CAAC,CACH,CCrIA,CAAA,IAAMI,EAA2B,KAGxB,CACL,QAHcP,CAAkC,CAAA,EAAE,CAIpD,CAAA","file":"StateManager.js","sourcesContent":["/**\n * Properties of observable\n */\nexport interface ObservableProps<T> {\n  initial: T;\n}\n\n/**\n * Observable methods\n */\nexport interface Observable<T> {\n  /**\n   *\n   * @description gets current state\n   * @returns currents state\n   */\n  getValue: () => T;\n  /**\n   * @description changes the current state to new state and notifies all listeners\n   * @param value the new state\n   */\n  setValue: (value: T) => void;\n  /**\n   * @description allows to look for changes\n   * @param fn callback function to be run when state changes\n   * @returns un subscribe function reference to unsubscribe when no longer needed\n   */\n  subscribeToChanges: (fn: (val: T) => void) => () => void;\n  /**\n   * @description allows clean up of unsubscribed functions\n   */\n  dispose: () => void;\n}\n\n/**\n * @description creates an observable for the given type with a initial state\n * @param props initial state of observable\n * @returns observable\n */\nexport const createObservable = <T>(\n  props: ObservableProps<T>\n): Observable<T> => {\n  let value = props.initial;\n  const listeners: Set<(val: T) => void> = new Set();\n  let scheduled: boolean = false;\n\n  /**\n   * @description changes the state to new state and notifies all listeners\n   * @param _value the new state\n   */\n  const setValue = (_value: T) => {\n    if (value === _value) {\n      return;\n    }\n    value = _value;\n    if (!scheduled) {\n      setTimeout(() => {\n        listeners.forEach((fn) => fn(_value));\n      }, 0);\n    }\n  };\n\n  /**\n   * @description gets the data of current state\n   * @returns the current state\n   */\n  const _getValue = () => {\n    return value;\n  };\n\n  /**\n   * @description subscribe to state changes\n   * @param fn the callback function when the state changes\n   * @returns un subscribe function to clean up\n   */\n  const subscribeToChanges = (fn: (val: T) => void) => {\n    listeners.add(fn);\n    return () => {\n      listeners.delete(fn);\n    };\n  };\n\n  /**\n   * @description clears the set so that there are no memory leaks\n   */\n  const dispose = () => {\n    listeners.clear();\n  };\n\n  return Object.freeze({\n    getValue: _getValue,\n    setValue: setValue,\n    subscribeToChanges: subscribeToChanges,\n    dispose: dispose,\n  });\n};\n","import { createObservable, Observable } from \"./observable\";\n\ntype ObservableMap = Record<string, Observable<any>>;\n\n/**\n * Here we map key to state\n *\n * [key in T i.e string] : U (type extracted from observable)\n *\n * key : U or never\n */\ntype ExtractState<T extends ObservableMap> = {\n  [K in keyof T]: T[K] extends Observable<infer U> ? U : never;\n};\n\nexport interface GlobalState {\n  /**\n   *@description populates the state with Initial values\n   */\n  inflate: () => void;\n  /**\n   * @description gets the current state\n   * @returns the state with fields for the given map\n   */\n  getState: <T extends ObservableMap>() => ExtractState<T>;\n  /**\n   * @description updates to the new state\n   * @param newState only the part of the state say eg loading state\n   */\n  setState: <T extends ObservableMap>(\n    newState: Partial<ExtractState<T>>\n  ) => void;\n  /**\n   * @description gets the observable\n   * @param key string\n   * @returns observable\n   */\n  getObservable: <K extends keyof ObservableMap>(\n    key: K\n  ) => Observable<ObservableMap[K]>;\n  /**\n   *\n   * @param key the state to which subscription is taken\n   * @param fn the callback function\n   * @returns un subscribe function\n   */\n  subscribe: <K extends keyof ObservableMap>(\n    key: K,\n    fn: (value: ObservableMap[K]) => void\n  ) => () => void;\n  /**\n   * @description clears up any left over observables\n   */\n  dispose: () => void;\n}\n\nexport const createGlobalState = <T extends Record<string, any>>(\n  map: Record<string, any>\n): GlobalState => {\n  const stateMap: T = {} as T;\n  /**\n   *@description inflates the state-map with values\n   */\n  const inflate = () => {\n    for (const key in map) {\n      const observable = createObservable({ initial: map[key] });\n      stateMap[key as keyof T] = observable as T[typeof key];\n    }\n  };\n\n  /**\n   * @description gets the state from observables\n   * @returns current state\n   */\n  const getState = <T extends ObservableMap>(): ExtractState<T> => {\n    const state = {} as ExtractState<T>;\n\n    for (const key in stateMap) {\n      state[key] = stateMap[key].getValue();\n    }\n\n    return state;\n  };\n\n  /**\n   * @description sets the new state\n   * @param newState the state which has to be updated\n   */\n  const setState = <T extends ObservableMap>(\n    newState: Partial<ExtractState<T>>\n  ) => {\n    for (const key in newState) {\n      if (stateMap[key]) {\n        stateMap[key].setValue(newState[key]);\n      }\n    }\n  };\n\n  /**\n   * @description gets the observable\n   * @param key string\n   * @returns observable for the key\n   */\n  const getObservable = <K extends keyof ObservableMap>(\n    key: K\n  ): Observable<ObservableMap[K]> => {\n    return stateMap[key];\n  };\n\n  /***\n   * @description subscribe to underlying observable\n   */\n  const subscribe = <K extends keyof ObservableMap>(\n    key: K,\n    fn: (value: T[K]) => void\n  ) => {\n    return stateMap[key].subscribeToChanges(fn);\n  };\n\n  /**\n   * dispose off any unwanted observables if any is left behind\n   */\n  const dispose = () => {\n    for (const key in stateMap) {\n      stateMap[key].dispose();\n    }\n  };\n\n  return Object.freeze({\n    inflate: inflate,\n    getState: getState,\n    setState: setState,\n    getObservable: getObservable,\n    subscribe: subscribe,\n    dispose: dispose,\n  });\n};\n","import { createGlobalState } from \"./globalState\";\nimport { GlobalStateManager, LoadingContext } from \"./stateType\";\n\nconst createGlobalStateManager = (): GlobalStateManager => {\n  const loading = createGlobalState<LoadingContext>({});\n\n  return {\n    loading: loading,\n  };\n};\n\nexport { createGlobalStateManager };\n"]}