{"version":3,"sources":["../../../src/plugins/loader/fbx_loader.ts","../../../src/plugins/loader/glb_loader.ts","../../../src/plugins/loader/hdr_loader.ts","../../../src/engine/core/LoadingManager.ts"],"names":["createFBXLoader","loadingManager","scene","storageManager","fbxLoader","FBXLoader","_loadMesh","metaData","model","err","assets","promises","asset","createGLBLoader","gltfLoader","GLTFLoader","dracoLoader","DRACOLoader","createHDRLoader","renderer","pmremGenerator","PMREMGenerator","rgbeLoader","RGBELoader","_loadHDRTexture","reject","resolve","data","texData","envMap","load","createLoader","loaderEventBus","stateManager","manager","LoadingManager","isConfigured","glbLoader","hdrLoader","assetQueue","_configureLoadingManager","url","itemsLoaded","itemsTotal","pushToRespectiveLoaderQueue","_configurePlugins"],"mappings":"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","file":"LoadingManager.js","sourcesContent":["import { GlobalStorageManager } from \"engine/managers/storage/storageTypes\";\nimport { Scene } from \"three\";\nimport { FBXLoader } from \"three/examples/jsm/loaders/FBXLoader.js\";\nimport type { LoadingManager } from \"three/src/loaders/LoadingManager.js\";\nimport { ModelAssetDescriptor } from \"types/loader.types\";\nimport { LoaderPlugin } from \"types/plugin.types\";\n\nexport interface FBXLoaderProps {\n  scene: Scene;\n  loadingManager: LoadingManager;\n  storageManager: GlobalStorageManager;\n}\n\nexport const createFBXLoader = ({\n  loadingManager,\n  scene,\n  storageManager,\n}: FBXLoaderProps): LoaderPlugin => {\n  const fbxLoader: FBXLoader = new FBXLoader(loadingManager);\n\n  /**\n   * @description load the mesh\n   * @param metaData meta-data for loading the mesh\n   */\n  const _loadMesh = async (metaData: ModelAssetDescriptor) => {\n    try {\n      const model = await fbxLoader.loadAsync(metaData.path);\n      storageManager.getStorage(\"model\").store(metaData.id, {\n        animations: model.animations,\n        groups: model,\n      });\n      scene.add(model);\n    } catch (err) {\n      throw new Error(`Error while loading fbx file : ${err}`);\n    }\n  };\n\n  const load = async (assets: ModelAssetDescriptor[]) => {\n    const promises: Promise<void>[] = [];\n    assets.forEach((asset) => {\n      promises.push(_loadMesh(asset));\n    });\n\n    await Promise.allSettled(promises);\n  };\n\n  return {\n    load: load,\n  };\n};\n","import { GlobalStorageManager } from \"engine/managers/storage/storageTypes\";\nimport { LoadingManager, Scene } from \"three\";\nimport { DRACOLoader } from \"three/examples/jsm/loaders/DRACOLoader.js\";\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader.js\";\nimport { ModelAssetDescriptor } from \"types/loader.types\";\nimport { LoaderPlugin } from \"types/plugin.types\";\n\nexport interface GLBLoaderProps {\n  scene: Scene;\n  loadingManager: LoadingManager;\n  storageManager: GlobalStorageManager;\n}\n\nexport const createGLBLoader = ({\n  scene,\n  loadingManager,\n  storageManager,\n}: GLBLoaderProps): LoaderPlugin => {\n  const gltfLoader: GLTFLoader = new GLTFLoader(loadingManager);\n  const dracoLoader = new DRACOLoader();\n  dracoLoader.setDecoderPath(\"/public/draco/\");\n  gltfLoader.setDRACOLoader(dracoLoader);\n\n  /**\n   * @description load the mesh\n   * @param metaData meta-data for loading the mesh\n   */\n  const _loadMesh = async (metaData: ModelAssetDescriptor) => {\n    try {\n      const model = await gltfLoader.loadAsync(metaData.path);\n      storageManager.getStorage(\"model\").store(metaData.id, {\n        animations: model.animations,\n        groups: model.scene,\n      });\n      scene.add(model.scene);\n    } catch (err) {\n      throw new Error(`Errr occuerd while loading a glb file : ${err}`);\n    }\n  };\n\n  const load = async (assets: ModelAssetDescriptor[]) => {\n    const promises: Promise<void>[] = [];\n    assets.forEach((asset) => {\n      promises.push(_loadMesh(asset));\n    });\n\n    await Promise.allSettled(promises);\n  };\n\n  return {\n    load: load,\n  };\n};\n","import { GlobalStorageManager } from \"engine/managers/storage/storageTypes\";\nimport {\n  DataTexture,\n  LoadingManager,\n  PMREMGenerator,\n  Scene,\n  WebGLRenderer,\n} from \"three\";\nimport { RGBELoader } from \"three/examples/jsm/loaders/RGBELoader.js\";\nimport { ModelAssetDescriptor } from \"types/loader.types\";\nimport { LoaderPlugin } from \"types/plugin.types\";\n\nexport interface HDRTextureLoaderProps {\n  scene: Scene;\n  renderer: WebGLRenderer;\n  loadingManager: LoadingManager;\n  storageManager: GlobalStorageManager;\n}\n\n/**\n * @description loads .hdr files and illuminates scene\n * @param props hdr loading properties\n * @returns HDR loader plugin\n */\nexport const createHDRLoader = ({\n  loadingManager,\n  renderer,\n  scene,\n}: HDRTextureLoaderProps): LoaderPlugin => {\n  const pmremGenerator: PMREMGenerator = new PMREMGenerator(renderer);\n  const rgbeLoader: RGBELoader = new RGBELoader(loadingManager);\n\n  /**\n   * @description loads a hdr file\n   * @param metaData meta-data for loading hdr\n   */\n  const _loadHDRTexture = async (\n    metaData: ModelAssetDescriptor\n  ): Promise<void> => {\n    return new Promise((reject, resolve) => {\n      console.log(\"path\", metaData.path);\n      rgbeLoader.load(\n        metaData.path,\n        (data: DataTexture, texData: object) => {\n          const envMap = pmremGenerator.fromEquirectangular(data).texture;\n          data.dispose();\n          scene.environment = envMap;\n          resolve();\n        },\n        undefined,\n        (err) => {\n          reject();\n        }\n      );\n    });\n  };\n\n  const load = async (assets: ModelAssetDescriptor[]) => {\n    const promises: Promise<void>[] = [];\n\n    assets.forEach(async (asset) => {\n      promises.push(_loadHDRTexture(asset));\n    });\n\n    await Promise.allSettled(promises);\n  };\n\n  const dispose = () => {\n    pmremGenerator.dispose();\n  };\n\n  return {\n    load: load,\n  };\n};\n","import { EventBus } from \"@events/eventBus\";\nimport { GlobalStorageManager } from \"engine/managers/storage/storageTypes\";\nimport { LoadingManager, Scene, WebGLRenderer } from \"three\";\nimport { LoadingEvents } from \"types/eventType\";\nimport { LoadOptions, ModelAssetDescriptor } from \"types/loader.types\";\nimport { createFBXLoader } from \"../../plugins/loader/fbx_loader\";\nimport { createGLBLoader } from \"../../plugins/loader/glb_loader\";\nimport { createHDRLoader } from \"../../plugins/loader/hdr_loader\";\nimport { GlobalStateManager, LoadingContext } from \"./state/stateType\";\n\nexport interface LoaderProps {\n  scene: Scene;\n  renderer: WebGLRenderer;\n  loaderEventBus: EventBus<LoadingEvents>;\n  stateManager: GlobalStateManager;\n  storageManager: GlobalStorageManager;\n}\n\nexport interface Loader {\n  configure: () => void;\n  load: (assets: ModelAssetDescriptor[]) => Promise<{\n    success: string[];\n    error: string[];\n  }>;\n  dispose: () => void;\n}\n/**\n * @description creates a loader with the given settings\n * @param options options to change loader settings\n * @param context global context with references\n * @returns Loader\n */\nexport const createLoader = ({\n  scene,\n  renderer,\n  loaderEventBus,\n  stateManager,\n  storageManager,\n}: LoaderProps): Loader => {\n  const manager: LoadingManager = new LoadingManager();\n  let isConfigured: boolean = false;\n  const [glbLoader, fbxLoader, hdrLoader] = [\n    createGLBLoader({\n      scene,\n      loadingManager: manager,\n      storageManager,\n    }),\n    createFBXLoader({\n      scene,\n      loadingManager: manager,\n      storageManager,\n    }),\n    createHDRLoader({\n      scene,\n      loadingManager: manager,\n      renderer,\n      storageManager,\n    }),\n  ];\n  const assetQueue: {\n    glb: ModelAssetDescriptor[];\n    fbx: ModelAssetDescriptor[];\n    hdr: ModelAssetDescriptor[];\n  } = {\n    glb: [],\n    fbx: [],\n    hdr: [],\n  };\n\n  /**\n   * @description attaches the event bus for listening to loading changes\n   */\n  const _configureLoadingManager = () => {\n    manager.onStart = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:start\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      stateManager.loading.setState({\n        loading: { active: true, progress: 0 } as LoadingContext,\n      });\n    };\n\n    manager.onProgress = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:progress\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      stateManager.loading.setState({\n        loading: {\n          active: true,\n          progress: itemsLoaded / itemsTotal,\n        } as LoadingContext,\n      });\n    };\n\n    manager.onLoad = () => {\n      loaderEventBus.emit({\n        type: \"load:complete\",\n      });\n    };\n\n    manager.onError = (url) => {\n      loaderEventBus.emit({\n        type: \"load:error\",\n        url: url,\n      });\n    };\n\n    isConfigured = true;\n  };\n\n  const pushToRespectiveLoaderQueue = (model: ModelAssetDescriptor) => {\n    switch (model.type) {\n      case \"glb\":\n        assetQueue.glb.push(model);\n        break;\n      case \"fbx\":\n        assetQueue.fbx.push(model);\n        break;\n      case \"hdr\":\n        assetQueue.hdr.push(model);\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * @description create necessary loaders\n   */\n  const _configurePlugins = (assets: ModelAssetDescriptor[]) => {\n    assets.forEach((asset) => {\n      pushToRespectiveLoaderQueue(asset);\n    });\n  };\n\n  /**\n   * @description configuration\n   */\n  const _configure = () => {\n    _configureLoadingManager();\n  };\n\n  /**\n   * @description load all types of assets\n   */\n  const load = async (\n    assets: LoadOptions\n  ): Promise<{ success: []; error: [] }> => {\n    if (!isConfigured)\n      throw new Error(\n        `Error: Trying to load from loader before configuring it`\n      );\n\n    const promises: Promise<void>[] = [];\n    _configurePlugins(assets);\n\n    promises.push(glbLoader.load(assetQueue.glb));\n    promises.push(fbxLoader.load(assetQueue.fbx));\n    promises.push(hdrLoader.load(assetQueue.hdr));\n\n    await Promise.allSettled(promises);\n    assetQueue.fbx = [];\n    assetQueue.glb = [];\n    assetQueue.hdr = [];\n\n    return {\n      success: [],\n      error: [],\n    };\n  };\n\n  const dispose = () => {};\n\n  return {\n    configure: _configure,\n    load: load,\n    dispose: dispose,\n  };\n};\n"]}