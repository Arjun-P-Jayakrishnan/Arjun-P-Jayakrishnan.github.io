{"version":3,"sources":["../src/utils/event_management/eventBus.ts"],"sourcesContent":["//A callback that handles specific event object of type T.\nexport type Listener<T> = (event: T) => void;\n\nexport interface EventBus<T extends { type: string }> {\n  /**\n   * @description subscribe to event\n   * @param type the event type\n   * @param callback the listener callback when event is triggered\n   */\n  on: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n\n  /**\n   * @description un-subscribe to event\n   * @param type event type to be un subscribe\n   * @param callback call back that has to be removed\n   */\n  off: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n\n  /**\n   * @description emits the event\n   * @param event event that must be emitted\n   */\n  emit: (event: T) => void;\n\n  /**\n   * @description clears all the listeners\n   */\n  clear: () => void;\n\n  once: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n}\n\n/**\n * @description creates an event Bus for a custom event type\n *\n * Note: event must be an object with a parameter {type:string,.....}\n * @returns\n */\nexport const createEventBus = <T extends { type: string }>(): EventBus<T> => {\n  /**\n   *  \"start\" -- its callbacks\n   */\n  const listeners = new Map<T[\"type\"], Set<Listener<T>>>();\n\n  /**\n   * @description register a listener for a specfic event type\n   * @param type event type\n   * @param callback extracts only the ones with the event type\n   */\n  const _on = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    if (!listeners.has(type)) {\n      listeners.set(type, new Set());\n    }\n\n    listeners.get(type)!.add(callback as Listener<T>);\n  };\n\n  /**\n   * @description un subscribe from the event\n   * @param type the event type\n   * @param callback the callback that has to be removed\n   */\n  const _off = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    listeners.get(type)?.delete(callback as Listener<T>);\n  };\n\n  /**\n   * @description similar in function to notify all\n   * @param event event that has to be triggered\n   */\n  const _emit = (event: T) => {\n    listeners.get(event.type)?.forEach((callback) => {\n      callback(event);\n    });\n  };\n\n  /**\n   * @description clean up function\n   */\n  const _clear = () => {\n    listeners.clear();\n  };\n\n  /**\n   * @description calls the function once\n   * @param type event type\n   * @param callback callback to be executed\n   */\n  const _once = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    const wrapper = (event: Extract<T, { type: K }>) => {\n      callback(event);\n      _off(type, wrapper);\n    };\n\n    _on(type, wrapper);\n  };\n\n  return Object.freeze({\n    on: _on,\n    off: _off,\n    emit: _emit,\n    clear: _clear,\n    once: _once,\n  });\n};\n"],"mappings":";AA+CO,IAAM,iBAAiB,MAA+C;AAI3E,QAAM,YAAY,oBAAI,IAAiC;AAOvD,QAAM,MAAM,CACV,MACA,aACG;AACH,QAAI,CAAC,UAAU,IAAI,IAAI,GAAG;AACxB,gBAAU,IAAI,MAAM,oBAAI,IAAI,CAAC;AAAA,IAC/B;AAEA,cAAU,IAAI,IAAI,EAAG,IAAI,QAAuB;AAAA,EAClD;AAOA,QAAM,OAAO,CACX,MACA,aACG;AACH,cAAU,IAAI,IAAI,GAAG,OAAO,QAAuB;AAAA,EACrD;AAMA,QAAM,QAAQ,CAAC,UAAa;AAC1B,cAAU,IAAI,MAAM,IAAI,GAAG,QAAQ,CAAC,aAAa;AAC/C,eAAS,KAAK;AAAA,IAChB,CAAC;AAAA,EACH;AAKA,QAAM,SAAS,MAAM;AACnB,cAAU,MAAM;AAAA,EAClB;AAOA,QAAM,QAAQ,CACZ,MACA,aACG;AACH,UAAM,UAAU,CAAC,UAAmC;AAClD,eAAS,KAAK;AACd,WAAK,MAAM,OAAO;AAAA,IACpB;AAEA,QAAI,MAAM,OAAO;AAAA,EACnB;AAEA,SAAO,OAAO,OAAO;AAAA,IACnB,IAAI;AAAA,IACJ,KAAK;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,EACR,CAAC;AACH;","names":[]}