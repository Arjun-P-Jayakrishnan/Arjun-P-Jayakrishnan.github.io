{"version":3,"sources":["../src/utils/event_management/eventBus.ts"],"sourcesContent":["//A callback that handles specific event object of type T.\nexport type Listener<T> = (event: T) => void;\n\nexport interface EventBus<T extends { type: string }> {\n  /**\n   * @description subscribe to event\n   * @param type the event type\n   * @param callback the listener callback when event is triggered\n   */\n  on: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n\n  /**\n   * @description un-subscribe to event\n   * @param type event type to be un subscribe\n   * @param callback call back that has to be removed\n   */\n  off: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n\n  /**\n   * @description emits the event\n   * @param event event that must be emitted\n   */\n  emit: (event: T) => void;\n\n  /**\n   * @description clears all the listeners\n   */\n  clear: () => void;\n\n  once: <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => void;\n}\n\n/**\n * @description creates an event Bus for a custom event type\n *\n * Note: event must be an object with a parameter {type:string,.....}\n * @returns\n */\nexport const createEventBus = <T extends { type: string }>(): EventBus<T> => {\n  /**\n   *  \"start\" -- its callbacks\n   */\n  const listeners = new Map<T[\"type\"], Set<Listener<T>>>();\n\n  /**\n   * @description register a listener for a specfic event type\n   * @param type event type\n   * @param callback extracts only the ones with the event type\n   */\n  const _on = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    if (!listeners.has(type)) {\n      listeners.set(type, new Set());\n    }\n\n    listeners.get(type)!.add(callback as Listener<T>);\n  };\n\n  /**\n   * @description un subscribe from the event\n   * @param type the event type\n   * @param callback the callback that has to be removed\n   */\n  const _off = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    listeners.get(type)?.delete(callback as Listener<T>);\n  };\n\n  /**\n   * @description similar in function to notify all\n   * @param event event that has to be triggered\n   */\n  const _emit = (event: T) => {\n    listeners.get(event.type)?.forEach((callback) => {\n      callback(event);\n    });\n  };\n\n  /**\n   * @description clean up function\n   */\n  const _clear = () => {\n    listeners.clear();\n  };\n\n  /**\n   * @description calls the function once\n   * @param type event type\n   * @param callback callback to be executed\n   */\n  const _once = <K extends T[\"type\"]>(\n    type: K,\n    callback: Listener<Extract<T, { type: K }>>\n  ) => {\n    const wrapper = (event: Extract<T, { type: K }>) => {\n      callback(event);\n      _off(type, wrapper);\n    };\n\n    _on(type, wrapper);\n  };\n\n  return Object.freeze({\n    on: _on,\n    off: _off,\n    emit: _emit,\n    clear: _clear,\n    once: _once,\n  });\n};\n"],"mappings":"AA+CO,IAAMA,EAAiB,IAA+C,CAI3E,IAAMC,EAAY,IAAI,IAOhBC,EAAM,CACVC,EACAC,IACG,CACEH,EAAU,IAAIE,CAAI,GACrBF,EAAU,IAAIE,EAAM,IAAI,GAAK,EAG/BF,EAAU,IAAIE,CAAI,EAAG,IAAIC,CAAuB,CAClD,EAOMC,EAAO,CACXF,EACAC,IACG,CACHH,EAAU,IAAIE,CAAI,GAAG,OAAOC,CAAuB,CACrD,EAoCA,OAAO,OAAO,OAAO,CACnB,GAAIF,EACJ,IAAKG,EACL,KAjCaC,GAAa,CAC1BL,EAAU,IAAIK,EAAM,IAAI,GAAG,QAASF,GAAa,CAC/CA,EAASE,CAAK,CAChB,CAAC,CACH,EA8BE,MAzBa,IAAM,CACnBL,EAAU,MAAM,CAClB,EAwBE,KAjBY,CACZE,EACAC,IACG,CACH,IAAMG,EAAWD,GAAmC,CAClDF,EAASE,CAAK,EACdD,EAAKF,EAAMI,CAAO,CACpB,EAEAL,EAAIC,EAAMI,CAAO,CACnB,CAQA,CAAC,CACH","names":["createEventBus","listeners","_on","type","callback","_off","event","wrapper"]}