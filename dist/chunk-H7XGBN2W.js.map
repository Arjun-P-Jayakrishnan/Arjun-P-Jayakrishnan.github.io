{"version":3,"sources":["../src/graphics/loader/loader.ts"],"sourcesContent":["import { createEventBus } from \"@utils/event_management/eventBus\";\nimport { LoadingEvents } from \"@utils/event_management/eventType\";\nimport { GlobalState } from \"@utils/state/globalState\";\nimport { LoadingContext } from \"@utils/state/globalStateData\";\nimport { LoadingManager, Scene, WebGLRenderer } from \"three\";\nimport { createHDRLoader } from \"./file_type_plugins/hdr_loader\";\nimport { createMeshLoader } from \"./file_type_plugins/mesh_loader\";\nimport { AssetMetaData, LoaderPlugin } from \"./loaderPlugins\";\n\nexport interface LoaderOptions {\n  meshesMetaData: AssetMetaData[];\n  hdrMetaData?: AssetMetaData;\n}\n\nexport interface LoaderContext {\n  scene: Scene;\n  renderer: WebGLRenderer;\n  loaderEventBus: ReturnType<typeof createEventBus<LoadingEvents>>;\n  globalState: GlobalState;\n}\n\nexport interface Loader {\n  configure: () => void;\n  loadAll: () => Promise<{\n    success: string[];\n    error: string[];\n  }>;\n  dispose: () => void;\n}\n/**\n * @description creates a loader with the given settings\n * @param options options to change loader settings\n * @param context global context with references\n * @returns Loader\n */\nexport const createLoader = (\n  options: LoaderOptions,\n  context: LoaderContext\n): Loader => {\n  const { scene, renderer, loaderEventBus, globalState } = context;\n  const { meshesMetaData, hdrMetaData } = options;\n\n  const manager: LoadingManager = new LoadingManager();\n  const plugins: LoaderPlugin[] = [];\n\n  /**\n   * @description attaches the event bus for listening to loading changes\n   */\n  const _configureLoadingManager = () => {\n    manager.onStart = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:start\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      globalState.setState({\n        loading: {\n          active: true,\n          progress: 0,\n        } as LoadingContext,\n      });\n    };\n\n    manager.onProgress = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:progress\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      globalState.setState({\n        loading: {\n          active: true,\n          progress: itemsLoaded / itemsTotal,\n        } as LoadingContext,\n      });\n    };\n\n    manager.onLoad = () => {\n      loaderEventBus.emit({\n        type: \"load:complete\",\n      });\n    };\n\n    manager.onError = (url) => {\n      loaderEventBus.emit({\n        type: \"load:error\",\n        url: url,\n      });\n    };\n  };\n\n  /**\n   * @description create necessary loaders\n   */\n  const _configurePlugins = () => {\n    if (meshesMetaData.length > 0) {\n      plugins.push(\n        createMeshLoader({\n          assets: meshesMetaData,\n          scene: scene,\n          loadingManager: manager,\n          loadingEventBus: loaderEventBus,\n        })\n      );\n    }\n\n    if (hdrMetaData !== undefined && hdrMetaData !== null) {\n      plugins.push(\n        createHDRLoader({\n          asset: hdrMetaData,\n          scene: scene,\n          renderer: renderer,\n          loadingManager: manager,\n          loadingEventBus: loaderEventBus,\n        })\n      );\n    }\n  };\n\n  /**\n   * @description configuration\n   */\n  const _configure = () => {\n    _configureLoadingManager();\n    _configurePlugins();\n  };\n\n  /**\n   * @description load all types of assets\n   */\n  const load = async (): Promise<{ success: []; error: [] }> => {\n    const promises: Promise<void>[] = [];\n\n    plugins.forEach((plugin) => {\n      promises.push(plugin.load());\n    });\n\n    await Promise.allSettled(promises);\n\n    return {\n      success: [],\n      error: [],\n    };\n  };\n\n  const dispose = () => {\n    plugins.forEach((plugin) => {\n      plugin.dispose?.();\n    });\n  };\n\n  return {\n    configure: _configure,\n    loadAll: load,\n    dispose: dispose,\n  };\n};\n"],"mappings":"gFAIA,OAAS,kBAAAA,MAA4C,QA+B9C,IAAMC,EAAe,CAC1BC,EACAC,IACW,CACX,GAAM,CAAE,MAAAC,EAAO,SAAAC,EAAU,eAAAC,EAAgB,YAAAC,CAAY,EAAIJ,EACnD,CAAE,eAAAK,EAAgB,YAAAC,CAAY,EAAIP,EAElCQ,EAA0B,IAAIC,EAC9BC,EAA0B,CAAC,EAK3BC,EAA2B,IAAM,CACrCH,EAAQ,QAAU,CAACI,EAAKC,EAAaC,IAAe,CAClDV,EAAe,KAAK,CAClB,KAAM,aACN,IAAKQ,EACL,OAAQC,EACR,MAAOC,CACT,CAAC,EACDT,EAAY,SAAS,CACnB,QAAS,CACP,OAAQ,GACR,SAAU,CACZ,CACF,CAAC,CACH,EAEAG,EAAQ,WAAa,CAACI,EAAKC,EAAaC,IAAe,CACrDV,EAAe,KAAK,CAClB,KAAM,gBACN,IAAKQ,EACL,OAAQC,EACR,MAAOC,CACT,CAAC,EACDT,EAAY,SAAS,CACnB,QAAS,CACP,OAAQ,GACR,SAAUQ,EAAcC,CAC1B,CACF,CAAC,CACH,EAEAN,EAAQ,OAAS,IAAM,CACrBJ,EAAe,KAAK,CAClB,KAAM,eACR,CAAC,CACH,EAEAI,EAAQ,QAAWI,GAAQ,CACzBR,EAAe,KAAK,CAClB,KAAM,aACN,IAAKQ,CACP,CAAC,CACH,CACF,EAKMG,EAAoB,IAAM,CAC1BT,EAAe,OAAS,GAC1BI,EAAQ,KACNM,EAAiB,CACf,OAAQV,EACR,MAAOJ,EACP,eAAgBM,EAChB,gBAAiBJ,CACnB,CAAC,CACH,EAG+BG,GAAgB,MAC/CG,EAAQ,KACNO,EAAgB,CACd,MAAOV,EACP,MAAOL,EACP,SAAUC,EACV,eAAgBK,EAChB,gBAAiBJ,CACnB,CAAC,CACH,CAEJ,EAkCA,MAAO,CACL,UA9BiB,IAAM,CACvBO,EAAyB,EACzBI,EAAkB,CACpB,EA4BE,QAvBW,SAAiD,CAC5D,IAAMG,EAA4B,CAAC,EAEnC,OAAAR,EAAQ,QAASS,GAAW,CAC1BD,EAAS,KAAKC,EAAO,KAAK,CAAC,CAC7B,CAAC,EAED,MAAM,QAAQ,WAAWD,CAAQ,EAE1B,CACL,QAAS,CAAC,EACV,MAAO,CAAC,CACV,CACF,EAWE,QATc,IAAM,CACpBR,EAAQ,QAASS,GAAW,CAC1BA,EAAO,UAAU,CACnB,CAAC,CACH,CAMA,CACF","names":["LoadingManager","createLoader","options","context","scene","renderer","loaderEventBus","globalState","meshesMetaData","hdrMetaData","manager","LoadingManager","plugins","_configureLoadingManager","url","itemsLoaded","itemsTotal","_configurePlugins","createMeshLoader","createHDRLoader","promises","plugin"]}