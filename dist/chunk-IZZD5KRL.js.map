{"version":3,"sources":["../src/graphics/loader/file_type_plugins/mesh_loader.ts"],"sourcesContent":["import { createEventBus } from \"@utils/event_management/eventBus\";\r\nimport type { LoadingEvents } from \"@utils/event_management/eventType\";\r\nimport { getGlobalContext } from \"@utils/globalContext\";\r\nimport { Scene } from \"three\";\r\nimport { DRACOLoader } from \"three/examples/jsm/loaders/DRACOLoader.js\";\r\nimport { GLTFLoader } from \"three/examples/jsm/loaders/GLTFLoader.js\";\r\nimport type { LoadingManager } from \"three/src/loaders/LoadingManager.js\";\r\nimport type { AssetMetaData, LoaderPlugin } from \"../loaderPlugins\";\r\n\r\nexport interface MeshLoaderProps {\r\n  assets: AssetMetaData[];\r\n  scene: Scene;\r\n  loadingManager: LoadingManager;\r\n  loadingEventBus: ReturnType<typeof createEventBus<LoadingEvents>>;\r\n}\r\n\r\nexport const createMeshLoader = (props: MeshLoaderProps): LoaderPlugin => {\r\n  const { assets, scene, loadingManager, loadingEventBus } = props;\r\n  const { globalStorage } = getGlobalContext();\r\n\r\n  const gltfLoader: GLTFLoader = new GLTFLoader(loadingManager);\r\n  const dracoLoader = new DRACOLoader();\r\n  dracoLoader.setDecoderPath(\"/public/draco/\");\r\n  gltfLoader.setDRACOLoader(dracoLoader);\r\n\r\n  /**\r\n   * @description load the mesh\r\n   * @param metaData meta-data for loading the mesh\r\n   */\r\n  const _loadMesh = async (metaData: AssetMetaData) => {\r\n    try {\r\n      const model = await gltfLoader.loadAsync(metaData.path);\r\n      globalStorage\r\n        .getStorage(\"animations\")\r\n        .store(metaData.name, model.animations);\r\n\r\n      scene.add(model.scene);\r\n      model.scene.position.set(0, 0, 0);\r\n      metaData.onSuccess?.();\r\n    } catch (err) {\r\n      metaData.onError?.(err as Error);\r\n      loadingEventBus.emit({ type: \"load:error\", url: metaData.path });\r\n      console.error(err);\r\n      throw err;\r\n    }\r\n  };\r\n\r\n  const load = async () => {\r\n    const promises: Promise<void>[] = [];\r\n    assets.forEach((asset) => {\r\n      promises.push(_loadMesh(asset));\r\n    });\r\n\r\n    await Promise.allSettled(promises);\r\n  };\r\n\r\n  const dispose = () => {};\r\n\r\n  return {\r\n    load: load,\r\n    dispose: dispose,\r\n  };\r\n};\r\n"],"mappings":";;;;;AAIA,SAAS,mBAAmB;AAC5B,SAAS,kBAAkB;AAWpB,IAAM,mBAAmB,CAAC,UAAyC;AACxE,QAAM,EAAE,QAAQ,OAAO,gBAAgB,gBAAgB,IAAI;AAC3D,QAAM,EAAE,cAAc,IAAI,iBAAiB;AAE3C,QAAM,aAAyB,IAAI,WAAW,cAAc;AAC5D,QAAM,cAAc,IAAI,YAAY;AACpC,cAAY,eAAe,gBAAgB;AAC3C,aAAW,eAAe,WAAW;AAMrC,QAAM,YAAY,OAAO,aAA4B;AACnD,QAAI;AACF,YAAM,QAAQ,MAAM,WAAW,UAAU,SAAS,IAAI;AACtD,oBACG,WAAW,YAAY,EACvB,MAAM,SAAS,MAAM,MAAM,UAAU;AAExC,YAAM,IAAI,MAAM,KAAK;AACrB,YAAM,MAAM,SAAS,IAAI,GAAG,GAAG,CAAC;AAChC,eAAS,YAAY;AAAA,IACvB,SAAS,KAAK;AACZ,eAAS,UAAU,GAAY;AAC/B,sBAAgB,KAAK,EAAE,MAAM,cAAc,KAAK,SAAS,KAAK,CAAC;AAC/D,cAAQ,MAAM,GAAG;AACjB,YAAM;AAAA,IACR;AAAA,EACF;AAEA,QAAM,OAAO,YAAY;AACvB,UAAM,WAA4B,CAAC;AACnC,WAAO,QAAQ,CAAC,UAAU;AACxB,eAAS,KAAK,UAAU,KAAK,CAAC;AAAA,IAChC,CAAC;AAED,UAAM,QAAQ,WAAW,QAAQ;AAAA,EACnC;AAEA,QAAM,UAAU,MAAM;AAAA,EAAC;AAEvB,SAAO;AAAA,IACL;AAAA,IACA;AAAA,EACF;AACF;","names":[]}