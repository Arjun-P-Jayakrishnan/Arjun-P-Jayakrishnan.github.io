{"version":3,"sources":["../src/engine/core/LoadingManager.ts"],"names":["createLoader","scene","renderer","loaderEventBus","stateManager","storageManager","manager","LoadingManager","isConfigured","glbLoader","hdrLoader","createGLBLoader","createHDRLoader","assetQueue","_configureLoadingManager","url","itemsLoaded","itemsTotal","pushToRespectiveLoaderQueue","model","_configurePlugins","assets","asset","promises"],"mappings":"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","file":"chunk-SWJKXIQY.js","sourcesContent":["import { EventBus } from \"@events/eventBus\";\nimport { GlobalStorageManager } from \"engine/managers/storage/storageTypes\";\nimport { LoadingManager, Scene, WebGLRenderer } from \"three\";\nimport { LoadingEvents } from \"types/event.types\";\nimport { LoadOptions, ModelAssetDescriptor } from \"types/loader.types\";\nimport { createGLBLoader } from \"../../plugins/loader/glb_loader\";\nimport { createHDRLoader } from \"../../plugins/loader/hdr_loader\";\nimport { GlobalStateManager, LoadingContext } from \"./state/stateType\";\n\nexport interface LoaderProps {\n  scene: Scene;\n  renderer: WebGLRenderer;\n  loaderEventBus: EventBus<LoadingEvents>;\n  stateManager: GlobalStateManager;\n  storageManager: GlobalStorageManager;\n}\n\nexport interface Loader {\n  configure: () => void;\n  load: (assets: ModelAssetDescriptor[]) => Promise<{\n    success: string[];\n    error: string[];\n  }>;\n  dispose: () => void;\n}\n/**\n * @description creates a loader with the given settings\n * @param options options to change loader settings\n * @param context global context with references\n * @returns Loader\n */\nexport const createLoader = ({\n  scene,\n  renderer,\n  loaderEventBus,\n  stateManager,\n  storageManager,\n}: LoaderProps): Loader => {\n  const manager: LoadingManager = new LoadingManager();\n  let isConfigured: boolean = false;\n  const [glbLoader, hdrLoader] = [\n    createGLBLoader({\n      scene,\n      loadingManager: manager,\n      storageManager,\n    }),\n    // createFBXLoader({\n    //   scene,\n    //   loadingManager: manager,\n    //   storageManager,\n    // }),\n    createHDRLoader({\n      scene,\n      loadingManager: manager,\n      renderer,\n      storageManager,\n    }),\n  ];\n  const assetQueue: {\n    glb: ModelAssetDescriptor[];\n    fbx: ModelAssetDescriptor[];\n    hdr: ModelAssetDescriptor[];\n  } = {\n    glb: [],\n    fbx: [],\n    hdr: [],\n  };\n\n  /**\n   * @description attaches the event bus for listening to loading changes\n   */\n  const _configureLoadingManager = () => {\n    manager.onStart = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:start\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      stateManager.loading.setState({\n        loading: { active: true, progress: 0 } as LoadingContext,\n      });\n    };\n\n    manager.onProgress = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:progress\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      stateManager.loading.setState({\n        loading: {\n          active: true,\n          progress: itemsLoaded / itemsTotal,\n        } as LoadingContext,\n      });\n    };\n\n    manager.onLoad = () => {\n      loaderEventBus.emit({\n        type: \"load:complete\",\n      });\n    };\n\n    manager.onError = (url) => {\n      loaderEventBus.emit({\n        type: \"load:error\",\n        url: url,\n      });\n    };\n\n    isConfigured = true;\n  };\n\n  const pushToRespectiveLoaderQueue = (model: ModelAssetDescriptor) => {\n    switch (model.type) {\n      case \"glb\":\n        assetQueue.glb.push(model);\n        break;\n      case \"fbx\":\n        assetQueue.fbx.push(model);\n        break;\n      case \"hdr\":\n        assetQueue.hdr.push(model);\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * @description create necessary loaders\n   */\n  const _configurePlugins = (assets: ModelAssetDescriptor[]) => {\n    assets.forEach((asset) => {\n      pushToRespectiveLoaderQueue(asset);\n    });\n  };\n\n  /**\n   * @description configuration\n   */\n  const _configure = () => {\n    _configureLoadingManager();\n  };\n\n  /**\n   * @description load all types of assets\n   */\n  const load = async (\n    assets: LoadOptions\n  ): Promise<{ success: []; error: [] }> => {\n    if (!isConfigured)\n      throw new Error(\n        `Error: Trying to load from loader before configuring it`\n      );\n\n    const promises: Promise<void>[] = [];\n    _configurePlugins(assets);\n\n    promises.push(glbLoader.load(assetQueue.glb));\n    // promises.push(fbxLoader.load(assetQueue.fbx));\n    promises.push(hdrLoader.load(assetQueue.hdr));\n\n    await Promise.allSettled(promises);\n    assetQueue.fbx = [];\n    assetQueue.glb = [];\n    assetQueue.hdr = [];\n\n    return {\n      success: [],\n      error: [],\n    };\n  };\n\n  const dispose = () => {};\n\n  return {\n    configure: _configure,\n    load: load,\n    dispose: dispose,\n  };\n};\n"]}