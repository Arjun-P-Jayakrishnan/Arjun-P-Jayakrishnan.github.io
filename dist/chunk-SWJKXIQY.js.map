{"version":3,"sources":["../src/engine/core/LoadingManager.ts"],"names":["createLoader","scene","renderer","loaderEventBus","stateManager","storageManager","manager","LoadingManager","isConfigured","glbLoader","hdrLoader","createGLBLoader","createHDRLoader","assetQueue","_configureLoadingManager","url","itemsLoaded","itemsTotal","pushToRespectiveLoaderQueue","model","_configurePlugins","assets","asset","promises"],"mappings":"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","file":"chunk-SWJKXIQY.js","sourcesContent":["import { EventBus } from \"@events/eventBus\";\nimport { GlobalStorageManager } from \"engine/managers/storage/storageTypes\";\nimport { LoadingManager, Scene, WebGLRenderer } from \"three\";\nimport { LoadingEvents } from \"types/event.types\";\nimport { LoadOptions, ModelAssetDescriptor } from \"types/loader.types\";\nimport { createGLBLoader } from \"../../plugins/loader/glb_loader\";\nimport { createHDRLoader } from \"../../plugins/loader/hdr_loader\";\nimport { GlobalStateManager, LoadingContext } from \"./state/stateType\";\n\nexport interface LoaderProps {\n  scene: Scene;\n  renderer: WebGLRenderer;\n  loaderEventBus: EventBus<LoadingEvents>;\n  stateManager: GlobalStateManager;\n  storageManager: GlobalStorageManager;\n}\n\nexport interface Loader {\n  configure: () => void;\n  load: (assets: ModelAssetDescriptor[]) => Promise<{\n    success: string[];\n    error: string[];\n  }>;\n  dispose: () => void;\n}\n/**\n * @description creates a loader with the given settings\n * @param options options to change loader settings\n * @param context global context with references\n * @returns Loader\n */\nexport const createLoader = ({\n  scene,\n  renderer,\n  loaderEventBus,\n  stateManager,\n  storageManager,\n}: LoaderProps): Loader => {\n  const manager: LoadingManager = new LoadingManager();\n  let isConfigured: boolean = false;\n  const [glbLoader, hdrLoader] = [\n    createGLBLoader({\n      scene,\n      loadingManager: manager,\n      storageManager,\n    }),\n    // createFBXLoader({\n    //   scene,\n    //   loadingManager: manager,\n    //   storageManager,\n    // }),\n    createHDRLoader({\n      scene,\n      loadingManager: manager,\n      renderer,\n      storageManager,\n    }),\n  ];\n  const assetQueue: {\n    glb: ModelAssetDescriptor[];\n    fbx: ModelAssetDescriptor[];\n    hdr: ModelAssetDescriptor[];\n  } = {\n    glb: [],\n    fbx: [],\n    hdr: [],\n  };\n\n  /**\n   * @description attaches the event bus for listening to loading changes\n   */\n  const _configureLoadingManager = () => {\n    manager.onStart = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:start\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      stateManager.loading.setState({\n        loading: { active: true, progress: 0 } as LoadingContext,\n      });\n    };\n\n    manager.onProgress = (url, itemsLoaded, itemsTotal) => {\n      loaderEventBus.emit({\n        type: \"load:progress\",\n        url: url,\n        loaded: itemsLoaded,\n        total: itemsTotal,\n      });\n      stateManager.loading.setState({\n        loading: {\n          active: true,\n          progress: itemsLoaded / itemsTotal,\n        } as LoadingContext,\n      });\n    };\n\n    manager.onLoad = () => {\n      loaderEventBus.emit({\n        type: \"load:complete\",\n      });\n    };\n\n    manager.onError = (url) => {\n      loaderEventBus.emit({\n        type: \"load:error\",\n        url: url,\n      });\n    };\n\n    isConfigured = true;\n  };\n\n  const pushToRespectiveLoaderQueue = (model: ModelAssetDescriptor) => {\n    switch (model.type) {\n      case \"glb\":\n        assetQueue.glb.push(model);\n        break;\n      case \"fbx\":\n        assetQueue.fbx.push(model);\n        break;\n      case \"hdr\":\n        assetQueue.hdr.push(model);\n        break;\n      default:\n        break;\n    }\n  };\n\n  /**\n   * @description create necessary loaders\n   */\n  const _configurePlugins = (assets: ModelAssetDescriptor[]) => {\n    assets.forEach((asset) => {\n      pushToRespectiveLoaderQueue(asset);\n    });\n  };\n\n  /**\n   * @description configuration\n   */\n  const _configure = () => {\n    _configureLoadingManager();\n  };\n\n  /**\n   * @description load all types of assets\n   */\n  const load = async (\n    assets: LoadOptions\n  ): Promise<{ success: []; error: [] }> => {\n    if (!isConfigured)\n      throw new Error(\n        `Error: Trying to load from loader before configuring it`\n      );\n\n    const promises: Promise<void>[] = [];\n    _configurePlugins(assets);\n\n    promises.push(glbLoader.load(assetQueue.glb));\n    // promises.push(fbxLoader.load(assetQueue.fbx));\n    promises.push(hdrLoader.load(assetQueue.hdr));\n\n    await Promise.allSettled(promises);\n    assetQueue.fbx = [];\n    assetQueue.glb = [];\n    assetQueue.hdr = [];\n\n    return {\n      success: [],\n      error: [],\n    };\n  };\n\n  const dispose = () => {};\n\n  return {\n    configure: _configure,\n    load: load,\n    dispose: dispose,\n  };\n};\n"]}