{"version":3,"sources":["../src/utils/event_management/eventBus.ts"],"sourcesContent":["//A callback that handles specific event object of type T.\r\nexport type Listener<T> = (event: T) => void;\r\n\r\nexport interface EventBus<T extends { type: string }> {\r\n  /**\r\n   * @description subscribe to event\r\n   * @param type the event type\r\n   * @param callback the listener callback when event is triggered\r\n   */\r\n  on: <K extends T[\"type\"]>(\r\n    type: K,\r\n    callback: Listener<Extract<T, { type: K }>>\r\n  ) => void;\r\n\r\n  /**\r\n   * @description un-subscribe to event\r\n   * @param type event type to be un subscribe\r\n   * @param callback call back that has to be removed\r\n   */\r\n  off: <K extends T[\"type\"]>(\r\n    type: K,\r\n    callback: Listener<Extract<T, { type: K }>>\r\n  ) => void;\r\n\r\n  /**\r\n   * @description emits the event\r\n   * @param event event that must be emitted\r\n   */\r\n  emit: (event: T) => void;\r\n\r\n  /**\r\n   * @description clears all the listeners\r\n   */\r\n  clear: () => void;\r\n\r\n  once: <K extends T[\"type\"]>(\r\n    type: K,\r\n    callback: Listener<Extract<T, { type: K }>>\r\n  ) => void;\r\n}\r\n\r\n/**\r\n * @description creates an event Bus for a custom event type\r\n *\r\n * Note: event must be an object with a parameter {type:string,.....}\r\n * @returns\r\n */\r\nexport const createEventBus = <T extends { type: string }>(): EventBus<T> => {\r\n  /**\r\n   *  \"start\" -- its callbacks\r\n   */\r\n  const listeners = new Map<T[\"type\"], Set<Listener<T>>>();\r\n\r\n  /**\r\n   * @description register a listener for a specfic event type\r\n   * @param type event type\r\n   * @param callback extracts only the ones with the event type\r\n   */\r\n  const _on = <K extends T[\"type\"]>(\r\n    type: K,\r\n    callback: Listener<Extract<T, { type: K }>>\r\n  ) => {\r\n    if (!listeners.has(type)) {\r\n      listeners.set(type, new Set());\r\n    }\r\n\r\n    listeners.get(type)!.add(callback as Listener<T>);\r\n  };\r\n\r\n  /**\r\n   * @description un subscribe from the event\r\n   * @param type the event type\r\n   * @param callback the callback that has to be removed\r\n   */\r\n  const _off = <K extends T[\"type\"]>(\r\n    type: K,\r\n    callback: Listener<Extract<T, { type: K }>>\r\n  ) => {\r\n    listeners.get(type)?.delete(callback as Listener<T>);\r\n  };\r\n\r\n  /**\r\n   * @description similar in function to notify all\r\n   * @param event event that has to be triggered\r\n   */\r\n  const _emit = (event: T) => {\r\n    listeners.get(event.type)?.forEach((callback) => {\r\n      callback(event);\r\n    });\r\n  };\r\n\r\n  /**\r\n   * @description clean up function\r\n   */\r\n  const _clear = () => {\r\n    listeners.clear();\r\n  };\r\n\r\n  /**\r\n   * @description calls the function once\r\n   * @param type event type\r\n   * @param callback callback to be executed\r\n   */\r\n  const _once = <K extends T[\"type\"]>(\r\n    type: K,\r\n    callback: Listener<Extract<T, { type: K }>>\r\n  ) => {\r\n    const wrapper = (event: Extract<T, { type: K }>) => {\r\n      callback(event);\r\n      _off(type, wrapper);\r\n    };\r\n\r\n    _on(type, wrapper);\r\n  };\r\n\r\n  return Object.freeze({\r\n    on: _on,\r\n    off: _off,\r\n    emit: _emit,\r\n    clear: _clear,\r\n    once: _once,\r\n  });\r\n};\r\n"],"mappings":";AA+CO,IAAM,iBAAiB,MAA+C;AAI3E,QAAM,YAAY,oBAAI,IAAiC;AAOvD,QAAM,MAAM,CACV,MACA,aACG;AACH,QAAI,CAAC,UAAU,IAAI,IAAI,GAAG;AACxB,gBAAU,IAAI,MAAM,oBAAI,IAAI,CAAC;AAAA,IAC/B;AAEA,cAAU,IAAI,IAAI,EAAG,IAAI,QAAuB;AAAA,EAClD;AAOA,QAAM,OAAO,CACX,MACA,aACG;AACH,cAAU,IAAI,IAAI,GAAG,OAAO,QAAuB;AAAA,EACrD;AAMA,QAAM,QAAQ,CAAC,UAAa;AAC1B,cAAU,IAAI,MAAM,IAAI,GAAG,QAAQ,CAAC,aAAa;AAC/C,eAAS,KAAK;AAAA,IAChB,CAAC;AAAA,EACH;AAKA,QAAM,SAAS,MAAM;AACnB,cAAU,MAAM;AAAA,EAClB;AAOA,QAAM,QAAQ,CACZ,MACA,aACG;AACH,UAAM,UAAU,CAAC,UAAmC;AAClD,eAAS,KAAK;AACd,WAAK,MAAM,OAAO;AAAA,IACpB;AAEA,QAAI,MAAM,OAAO;AAAA,EACnB;AAEA,SAAO,OAAO,OAAO;AAAA,IACnB,IAAI;AAAA,IACJ,KAAK;AAAA,IACL,MAAM;AAAA,IACN,OAAO;AAAA,IACP,MAAM;AAAA,EACR,CAAC;AACH;","names":[]}