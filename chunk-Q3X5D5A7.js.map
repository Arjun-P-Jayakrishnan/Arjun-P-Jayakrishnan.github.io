{"version":3,"sources":["../src/utils/state/observable.ts"],"sourcesContent":["/**\n * Properties of observable\n */\nexport interface ObservableProps<T> {\n  initial: T;\n}\n\n/**\n * Observable methods\n */\nexport interface Observable<T> {\n  /**\n   *\n   * @description gets current state\n   * @returns currents state\n   */\n  getValue: () => T;\n  /**\n   * @description changes the current state to new state and notifies all listeners\n   * @param value the new state\n   */\n  setValue: (value: T) => void;\n  /**\n   * @description allows to look for changes\n   * @param fn callback function to be run when state changes\n   * @returns un subscribe function reference to unsubscribe when no longer needed\n   */\n  subscribeToChanges: (fn: (val: T) => void) => () => void;\n  /**\n   * @description allows clean up of unsubscribed functions\n   */\n  dispose: () => void;\n}\n\n/**\n * @description creates an observable for the given type with a initial state\n * @param props initial state of observable\n * @returns observable\n */\nexport const createObservable = <T>(\n  props: ObservableProps<T>\n): Observable<T> => {\n  let value = props.initial;\n  const listeners: Set<(val: T) => void> = new Set();\n  let scheduled: boolean = false;\n\n  /**\n   * @description changes the state to new state and notifies all listeners\n   * @param _value the new state\n   */\n  const setValue = (_value: T) => {\n    if (value === _value) {\n      return;\n    }\n    value = _value;\n    if (!scheduled) {\n      setTimeout(() => {\n        listeners.forEach((fn) => fn(_value));\n      }, 0);\n    }\n  };\n\n  /**\n   * @description gets the data of current state\n   * @returns the current state\n   */\n  const _getValue = () => {\n    return value;\n  };\n\n  /**\n   * @description subscribe to state changes\n   * @param fn the callback function when the state changes\n   * @returns un subscribe function to clean up\n   */\n  const subscribeToChanges = (fn: (val: T) => void) => {\n    listeners.add(fn);\n    return () => {\n      listeners.delete(fn);\n    };\n  };\n\n  /**\n   * @description clears the set so that there are no memory leaks\n   */\n  const dispose = () => {\n    listeners.clear();\n  };\n\n  return Object.freeze({\n    getValue: _getValue,\n    setValue: setValue,\n    subscribeToChanges: subscribeToChanges,\n    dispose: dispose,\n  });\n};\n"],"mappings":";AAuCO,IAAM,mBAAmB,CAC9B,UACkB;AAClB,MAAI,QAAQ,MAAM;AAClB,QAAM,YAAmC,oBAAI,IAAI;AACjD,MAAI,YAAqB;AAMzB,QAAM,WAAW,CAAC,WAAc;AAC9B,QAAI,UAAU,QAAQ;AACpB;AAAA,IACF;AACA,YAAQ;AACR,QAAI,CAAC,WAAW;AACd,iBAAW,MAAM;AACf,kBAAU,QAAQ,CAAC,OAAO,GAAG,MAAM,CAAC;AAAA,MACtC,GAAG,CAAC;AAAA,IACN;AAAA,EACF;AAMA,QAAM,YAAY,MAAM;AACtB,WAAO;AAAA,EACT;AAOA,QAAM,qBAAqB,CAAC,OAAyB;AACnD,cAAU,IAAI,EAAE;AAChB,WAAO,MAAM;AACX,gBAAU,OAAO,EAAE;AAAA,IACrB;AAAA,EACF;AAKA,QAAM,UAAU,MAAM;AACpB,cAAU,MAAM;AAAA,EAClB;AAEA,SAAO,OAAO,OAAO;AAAA,IACnB,UAAU;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACH;","names":[]}